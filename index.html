<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>üíé 3D NFT Universe</title>

<!-- Supabase & Web3.js & WalletConnect -->
<script src="https://unpkg.com/@supabase/supabase-js"></script>
<script src="https://cdn.jsdelivr.net/npm/web3/dist/web3.min.js"></script>
<script src="https://unpkg.com/@walletconnect/web3-provider@1.8.0/dist/umd/index.min.js"></script>

<!-- Three.js for 3D rendering -->
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>

<style>
  :root {
    --bg: #f8fafc;
    --card-bg: #ffffff;
    --text-dark: #1e293b;
    --text-light: #475569;
    --accent: #3b82f6;
    --shadow: 0 4px 12px rgba(0,0,0,0.08);
  }
  
  .homepage{
    border-style: outset;
    width: 120px;
    height: 45px;
    background-image: url('https://i.pinimg.com/564x/35/38/ed/3538edbdb531c7fe3bb387ead4b398b0.jpg');
    background-size: 120px 45px;
    border-radius: 50%;
    text-align: center;
    line-height: 45px;
    color: white;
    font-weight: bold;
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 100;
    font-size: 0.8rem;
  }
  
  * { box-sizing: border-box; }
  body { 
    font-family: system-ui, sans-serif; 
    background: var(--bg); 
    margin: 0; 
    padding: 0; 
    color: var(--text-dark); 
    overflow: hidden;
    touch-action: none;
  }
  
  header { 
    background: var(--card-bg); 
    text-align: center; 
    padding: 12px 8px; 
    border-bottom: 1px solid #e2e8f0; 
    position: absolute; 
    top: 0; 
    width: 100%; 
    z-index: 10; 
  }
  
  h1 { font-size: 1.4rem; margin: 0; }
  #walletStatus { margin-top: 6px; font-size: 0.8rem; color: var(--text-light); }
  #connectBtn { 
    margin-top: 4px; 
    padding: 4px 8px;
    font-size: 0.8rem;
  }
  
  #canvas-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }
  
  #instructions {
    position: absolute;
    bottom: 10px;
    left: 0;
    width: 100%;
    text-align: center;
    color: white;
    background-color: rgba(0,0,0,0.7);
    padding: 8px;
    z-index: 100;
    font-size: 0.8rem;
  }
  
  #mobile-controls {
    position: absolute;
    bottom: 80px;
    right: 10px;
    z-index: 100;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  
  .mobile-btn {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: rgba(59, 130, 246, 0.7);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.2rem;
    font-weight: bold;
    user-select: none;
    -webkit-user-select: none;
    touch-action: manipulation;
  }
  
  #look-controls {
    position: absolute;
    bottom: 80px;
    left: 10px;
    width: 120px;
    height: 120px;
    z-index: 100;
    background: rgba(0,0,0,0.2);
    border-radius: 50%;
    touch-action: none;
  }
  
  #nft-modal {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--card-bg);
    border-radius: 16px;
    box-shadow: var(--shadow);
    padding: 20px;
    z-index: 1000;
    max-width: 90%;
    width: 350px;
    max-height: 80vh;
    overflow-y: auto;
  }
  
  #nft-modal img {
    width: 100%;
    height: 200px;
    object-fit: cover;
    display: block;
    border-radius: 8px;
    margin-bottom: 15px;
  }
  
  #nft-modal h3 {
    margin: 8px 0 4px;
    font-size: 1.1rem;
    font-weight: 600;
  }
  
  #nft-modal p {
    margin: 4px 0;
    font-size: 0.9rem;
    color: var(--text-light);
  }
  
  .nft-actions {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-top: 10px;
  }
  
  button {
    border: none;
    background: var(--accent);
    color: white;
    padding: 8px 12px;
    border-radius: 8px;
    font-size: 0.85rem;
    cursor: pointer;
    transition: background 0.2s;
  }
  
  button:hover {
    background: #2563eb;
  }
  
  #close-modal {
    position: absolute;
    top: 10px;
    right: 10px;
    background: #ef4444;
    width: 30px;
    height: 30px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  #close-modal:hover {
    background: #dc2626;
  }
  
  #mini-map {
    position: absolute;
    top: 70px;
    right: 10px;
    width: 120px;
    height: 120px;
    background: rgba(0,0,0,0.5);
    border-radius: 8px;
    z-index: 100;
    border: 2px solid white;
  }
  
  #location-info {
    position: absolute;
    top: 70px;
    left: 10px;
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 8px 12px;
    border-radius: 8px;
    font-size: 0.8rem;
    z-index: 100;
    max-width: 200px;
  }
  
  #avatar-selection {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.8);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 2000;
  }
  
  #avatar-selection h2 {
    color: white;
    margin-bottom: 30px;
    font-size: 1.8rem;
  }
  
  .avatar-options {
    display: flex;
    gap: 30px;
    flex-wrap: wrap;
    justify-content: center;
  }
  
  .avatar-option {
    width: 200px;
    height: 300px;
    border-radius: 12px;
    overflow: hidden;
    cursor: pointer;
    transition: transform 0.3s, box-shadow 0.3s;
    border: 3px solid transparent;
  }
  
  .avatar-option:hover {
    transform: scale(1.05);
    box-shadow: 0 10px 20px rgba(0,0,0,0.3);
  }
  
  .avatar-option.selected {
    border-color: var(--accent);
    box-shadow: 0 0 20px var(--accent);
  }
  
  #boy-avatar {
    background-image: url('https://raw.githubusercontent.com/diamondrolls/images/main/431BBB65-C6F8-49BC-B882-EA5BBE885462.png');
    background-size: cover;
    background-position: center;
  }
  
  #girl-avatar {
    background-image: url('https://raw.githubusercontent.com/diamondrolls/images/main/3974D02C-0D5B-4F49-8597-5185D48FB2A1.png');
    background-size: cover;
    background-position: center;
  }
  
  #confirm-avatar {
    margin-top: 30px;
    padding: 12px 24px;
    font-size: 1.1rem;
    background: var(--accent);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.2s;
  }
  
  #confirm-avatar:hover {
    background: #2563eb;
  }
  
  @media (max-width: 500px) { 
    header h1 { font-size: 1.2rem; } 
    #instructions {
      font-size: 0.7rem;
      bottom: 5px;
    }
    #mobile-controls {
      bottom: 60px;
    }
    #look-controls {
      bottom: 60px;
      width: 100px;
      height: 100px;
    }
    .mobile-btn {
      width: 45px;
      height: 45px;
      font-size: 1rem;
    }
    #mini-map {
      width: 100px;
      height: 100px;
      top: 60px;
    }
    .avatar-option {
      width: 150px;
      height: 225px;
    }
    #avatar-selection h2 {
      font-size: 1.4rem;
    }
    #location-info {
      top: 60px;
      font-size: 0.7rem;
      max-width: 150px;
    }
  }
</style>
</head>
<body>

<header>
  <h1>NFT Universe Explorer</h1>
  <div id="walletStatus">Not connected</div>
  <button id="connectBtn">Connect Wallet</button>
</header>

<a href='https://diamondrolls.github.io/thepremiumway/'> 
  <div class="homepage">Home</div>
</a>

<div id="canvas-container"></div>

<div id="instructions">
  <div id="desktop-instructions">Click to lock pointer and navigate with WASD keys. Move mouse to look around. Press SPACE to jump. Find the moon bridge in the center spiraling up to the moon! Swim in the pool and explore the underwater cave with zero gravity!</div>
  <div id="mobile-instructions" style="display:none;">Use controls to move and look around. Find NFTs everywhere! Find the moon bridge in the center spiraling up to the moon! Swim in the pool and explore the underwater cave with zero gravity!</div>
</div>

<div id="location-info">
  Location: Starting Area
</div>

<div id="mobile-controls">
  <div class="mobile-btn" id="forward-btn">‚Üë</div>
  <div style="display:flex; gap:10px;">
    <div class="mobile-btn" id="left-btn">‚Üê</div>
    <div class="mobile-btn" id="backward-btn">‚Üì</div>
    <div class="mobile-btn" id="right-btn">‚Üí</div>
  </div>
  <div class="mobile-btn" id="jump-btn" style="background: rgba(34, 197, 94, 0.7);">‚§¥</div>
</div>

<div id="look-controls"></div>

<div id="mini-map"></div>

<div id="nft-modal">
  <button id="close-modal">X</button>
  <img id="modal-image" src="" alt="NFT" />
  <div class="nft-info">
    <h3 id="modal-title"></h3>
    <p id="modal-description"></p>
    <p><strong>Price:</strong> <span id="modal-price"></span> ETH</p>
    <div class="nft-actions" id="modal-actions"></div>
  </div>
</div>

<div id="avatar-selection">
  <h2>Choose Your Explorer</h2>
  <div class="avatar-options">
    <div class="avatar-option" id="boy-avatar" data-avatar="boy"></div>
    <div class="avatar-option" id="girl-avatar" data-avatar="girl"></div>
  </div>
  <button id="confirm-avatar">Start Exploring</button>
</div>

<script>
/* ==============================
   CONFIGURATION
============================== */
const supabaseUrl = "https://fjtzodjudyctqacunlqp.supabase.co";
const supabaseKey = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZqdHpvZGp1ZHljdHFhY3VubHFwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgwNjA2OTQsImV4cCI6MjA3MzYzNjY5NH0.qR9RBsecfGUfKnbWgscmxloM-oEClJs_bo5YWoxFoE4";
const client = supabase.createClient(supabaseUrl, supabaseKey);

const NFT_CONTRACT_ADDRESS = "0x3ed4474a942d885d5651c8c56b238f3f4f524a5c";
const NFT_ABI = [
  { "constant":true,"inputs":[{"name":"tokenId","type":"uint256"}],"name":"ownerOf","outputs":[{"name":"","type":"address"}],"type":"function" },
  { "constant":false,"inputs":[{"name":"from","type":"address"},{"name":"to","type":"address"},{"name":"tokenId","type":"uint256"}],"name":"safeTransferFrom","outputs":[],"type":"function" }
];
const RECEIVER_ADDRESS = "0xaE0C180e071eE288B2F2f6ff6edaeF014678fFB7";

let web3, account, nftContract;

/* ==============================
   AVATAR SELECTION
============================== */
let selectedAvatar = null;
const avatarOptions = document.querySelectorAll('.avatar-option');
const confirmButton = document.getElementById('confirm-avatar');
const avatarSelection = document.getElementById('avatar-selection');

avatarOptions.forEach(option => {
  option.addEventListener('click', () => {
    // Remove selected class from all options
    avatarOptions.forEach(opt => opt.classList.remove('selected'));
    // Add selected class to clicked option
    option.classList.add('selected');
    selectedAvatar = option.getAttribute('data-avatar');
  });
});

confirmButton.addEventListener('click', () => {
  if (selectedAvatar) {
    avatarSelection.style.display = 'none';
    init3DScene();
    loadNFTs();
  } else {
    alert('Please select an avatar to continue');
  }
});

/* ==============================
   MOBILE DETECTION & CONTROLS
============================== */
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
let lookTouchId = null;
let lookStartX = 0, lookStartY = 0;
let lookX = 0, lookY = 0;
let velocity = new THREE.Vector3();
let canJump = true;

if (isMobile) {
  document.getElementById('desktop-instructions').style.display = 'none';
  document.getElementById('mobile-instructions').style.display = 'block';
  
  // Set up mobile movement controls
  document.getElementById('forward-btn').addEventListener('touchstart', (e) => {
    e.preventDefault();
    moveForward = true;
  });
  document.getElementById('forward-btn').addEventListener('touchend', (e) => {
    e.preventDefault();
    moveForward = false;
  });
  
  document.getElementById('backward-btn').addEventListener('touchstart', (e) => {
    e.preventDefault();
    moveBackward = true;
  });
  document.getElementById('backward-btn').addEventListener('touchend', (e) => {
    e.preventDefault();
    moveBackward = false;
  });
  
  document.getElementById('left-btn').addEventListener('touchstart', (e) => {
    e.preventDefault();
    moveLeft = true;
  });
  document.getElementById('left-btn').addEventListener('touchend', (e) => {
    e.preventDefault();
    moveLeft = false;
  });
  
  document.getElementById('right-btn').addEventListener('touchstart', (e) => {
    e.preventDefault();
    moveRight = true;
  });
  document.getElementById('right-btn').addEventListener('touchend', (e) => {
    e.preventDefault();
    moveRight = false;
  });
  
  document.getElementById('jump-btn').addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (canJump) {
      velocity.y += 350;
      canJump = false;
    }
  });
  
  // Set up look controls
  const lookControls = document.getElementById('look-controls');
  lookControls.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (lookTouchId === null) {
      const touch = e.touches[0];
      lookTouchId = touch.identifier;
      lookStartX = touch.clientX;
      lookStartY = touch.clientY;
    }
  });
  
  lookControls.addEventListener('touchmove', (e) => {
    e.preventDefault();
    for (let i = 0; i < e.changedTouches.length; i++) {
      const touch = e.changedTouches[i];
      if (touch.identifier === lookTouchId) {
        const deltaX = touch.clientX - lookStartX;
        const deltaY = touch.clientY - lookStartY;
        
        lookX = deltaX * 0.5;
        lookY = deltaY * 0.5;
        
        lookStartX = touch.clientX;
        lookStartY = touch.clientY;
        break;
      }
    }
  });
  
  lookControls.addEventListener('touchend', (e) => {
    e.preventDefault();
    for (let i = 0; i < e.changedTouches.length; i++) {
      const touch = e.changedTouches[i];
      if (touch.identifier === lookTouchId) {
        lookTouchId = null;
        lookX = 0;
        lookY = 0;
        break;
      }
    }
  });
}

/* ==============================
   3D SCENE SETUP - THIRD PERSON
============================== */
let scene, camera, renderer, controls;
let nftObjects = [], environmentObjects = [], buildingObjects = [];
let raycaster, mouse;
let currentIntersected = null;
let miniMapScene, miniMapCamera, miniMapRenderer;
let playerAvatar;
let worldSize = 800;
let worldBoundary = worldSize / 2 - 50;
let moon;
let clock = new THREE.Clock();
let prevTime = 0;

// Third-person camera variables
let cameraDistance = 25;
let cameraHeight = 10;
let cameraAngle = 0;
let targetCameraAngle = 0;

// Floating board variables
let hoverBoard;
let hoverHeight = 3; // Height above ground
let hoverBobSpeed = 2; // Bobbing speed
let hoverBobAmount = 0.3; // Bobbing amount
let hoverTime = 0;

// Collision detection variables
let collisionObjects = [];
let roofObjects = [];
let playerCollider = new THREE.Box3();
let playerSize = new THREE.Vector3(8, 1, 8); // Same size as NFT displays
let playerOnRoof = false;
let currentRoof = null;

// Swimming pool variables
let poolGroup;
let underwaterCaveGroup;
let isInWater = false;
let isInUnderwaterCave = false;

function init3DScene() {
  // Create scene
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000033);
  scene.fog = new THREE.Fog(0x000033, 100, 2000);
  
  // Create camera - Third person perspective
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
  
  // Create renderer
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.getElementById('canvas-container').appendChild(renderer.domElement);
  
  // Add lighting
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
  scene.add(ambientLight);
  
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  directionalLight.position.set(100, 200, 100);
  directionalLight.castShadow = true;
  directionalLight.shadow.mapSize.width = 2048;
  directionalLight.shadow.mapSize.height = 2048;
  directionalLight.shadow.camera.near = 0.5;
  directionalLight.shadow.camera.far = 2000;
  directionalLight.shadow.camera.left = -500;
  directionalLight.shadow.camera.right = 500;
  directionalLight.shadow.camera.top = 500;
  directionalLight.shadow.camera.bottom = -500;
  scene.add(directionalLight);
  
  // Create the world
  createWorld();
  
  // Create player avatar with floating board
  createPlayerAvatar();
  
  // Set initial camera position for third-person view
  updateThirdPersonCamera();
  
  // Set up controls
  if (!isMobile) {
    controls = new THREE.PointerLockControls(camera, document.body);
    
    document.addEventListener('click', function() {
      if (!controls.isLocked) {
        controls.lock();
      }
    });
    
    controls.addEventListener('lock', function() {
      document.getElementById('instructions').style.display = 'none';
    });
    
    controls.addEventListener('unlock', function() {
      document.getElementById('instructions').style.display = 'block';
    });
    
    // Keyboard controls for desktop
    const onKeyDown = function (event) {
      switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
          moveForward = true;
          break;
        case 'ArrowLeft':
        case 'KeyA':
          moveLeft = true;
          break;
        case 'ArrowDown':
        case 'KeyS':
          moveBackward = true;
          break;
        case 'ArrowRight':
        case 'KeyD':
          moveRight = true;
          break;
        case 'Space':
          if (canJump) {
            velocity.y += 350;
            canJump = false;
          }
          break;
      }
    };
    
    const onKeyUp = function (event) {
      switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
          moveForward = false;
          break;
        case 'ArrowLeft':
        case 'KeyA':
          moveLeft = false;
          break;
        case 'ArrowDown':
        case 'KeyS':
          moveBackward = false;
          break;
        case 'ArrowRight':
        case 'KeyD':
          moveRight = false;
          break;
      }
    };
    
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);
    
    // Mouse movement for third-person camera
    document.addEventListener('mousemove', (event) => {
      if (controls && controls.isLocked) {
        targetCameraAngle -= event.movementX * 0.002;
      }
    });
  }
  
  // Set up raycaster for object interaction
  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2();
  
  // Handle window resize
  window.addEventListener('resize', onWindowResize);
  
  // Initialize mini-map
  initMiniMap();
  
  // Start animation
  animate();
}

function updateThirdPersonCamera() {
  if (!playerAvatar) return;
  
  // Smoothly interpolate camera angle
  cameraAngle += (targetCameraAngle - cameraAngle) * 0.1;
  
  // Calculate camera position behind and above the player
  const playerPosition = playerAvatar.position.clone();
  const offset = new THREE.Vector3(
    Math.sin(cameraAngle) * cameraDistance,
    cameraHeight,
    Math.cos(cameraAngle) * cameraDistance
  );
  
  camera.position.copy(playerPosition).add(offset);
  
  // Look at a point slightly above the player's position
  const lookAtPosition = playerPosition.clone();
  lookAtPosition.y += 3; // Look at center of avatar
  camera.lookAt(lookAtPosition);
}

function createWorld() {
  // Create massive ground plane
  const groundGeometry = new THREE.PlaneGeometry(worldSize, worldSize, 100, 100);
  const groundMaterial = new THREE.MeshLambertMaterial({ 
    color: 0x4ADE80,
    side: THREE.DoubleSide
  });
  const ground = new THREE.Mesh(groundGeometry, groundMaterial);
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);
  
  // Create city with buildings (positioned around the center)
  createCity();
  
  // Create moon in the sky (moved further left)
  createMoon();
  
  // Create spiral bridge to the moon starting from center
  createMoonBridge();
  
  // Create swimming pool and underwater cave
  createSwimmingPool();
  
  // Add boundary walls to prevent going off map
  createBoundaryWalls();
}

function createSwimmingPool() {
  poolGroup = new THREE.Group();
  
  // Pool dimensions
  const poolWidth = 80;  // Same width as a building
  const poolLength = 80; // Same length as a building
  const poolDepth = 15;  // Depth of the pool
  
  // Create pool basin (hole in the ground)
  const poolBasinGeometry = new THREE.BoxGeometry(poolWidth, poolDepth, poolLength);
  const poolBasinMaterial = new THREE.MeshLambertMaterial({ 
    color: 0x1E40AF, // Deep blue for water
    transparent: true,
    opacity: 0.7
  });
  
  const poolBasin = new THREE.Mesh(poolBasinGeometry, poolBasinMaterial);
  poolBasin.position.set(0, -poolDepth/2, 0); // Position below ground level
  poolBasin.receiveShadow = true;
  poolGroup.add(poolBasin);
  
  // Create pool walls
  const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x374151 });
  
  // North wall
  const northWall = new THREE.Mesh(new THREE.BoxGeometry(poolWidth, poolDepth, 2), wallMaterial);
  northWall.position.set(0, -poolDepth/2, -poolLength/2);
  poolGroup.add(northWall);
  
  // South wall
  const southWall = new THREE.Mesh(new THREE.BoxGeometry(poolWidth, poolDepth, 2), wallMaterial);
  southWall.position.set(0, -poolDepth/2, poolLength/2);
  poolGroup.add(southWall);
  
  // East wall
  const eastWall = new THREE.Mesh(new THREE.BoxGeometry(2, poolDepth, poolLength), wallMaterial);
  eastWall.position.set(poolWidth/2, -poolDepth/2, 0);
  poolGroup.add(eastWall);
  
  // West wall
  const westWall = new THREE.Mesh(new THREE.BoxGeometry(2, poolDepth, poolLength), wallMaterial);
  westWall.position.set(-poolWidth/2, -poolDepth/2, 0);
  poolGroup.add(westWall);
  
  // Create pool ramps for easy entry/exit
  createPoolRamps(poolWidth, poolLength, poolDepth);
  
  // Create underwater cave entrance at the bottom of the pool
  createUnderwaterCave(poolWidth, poolLength, poolDepth);
  
  // Position pool to the side (not in center where bridge starts)
  poolGroup.position.set(150, 0, 150);
  scene.add(poolGroup);
  
  // Add pool walls to collision objects
  const poolBox = new THREE.Box3().setFromCenterAndSize(
    new THREE.Vector3(150, -poolDepth/2, 150),
    new THREE.Vector3(poolWidth, poolDepth, poolLength)
  );
  collisionObjects.push(poolBox);
}

function createPoolRamps(poolWidth, poolLength, poolDepth) {
  // Create entry ramp (sloping down into pool)
  const entryRampWidth = 20;
  const entryRampLength = poolLength / 2;
  const entryRampHeight = poolDepth / 2;
  
  const entryRampGeometry = new THREE.BoxGeometry(entryRampWidth, 1, entryRampLength);
  const rampMaterial = new THREE.MeshLambertMaterial({ color: 0x6B7280 });
  
  const entryRamp = new THREE.Mesh(entryRampGeometry, rampMaterial);
  entryRamp.position.set(0, -entryRampHeight/2, -poolLength/4);
  entryRamp.rotation.x = -Math.atan2(entryRampHeight, entryRampLength); // Slope downward
  entryRamp.castShadow = true;
  entryRamp.receiveShadow = true;
  poolGroup.add(entryRamp);
  
  // Create exit ramp (sloping up from bottom of pool)
  const exitRampWidth = 20;
  const exitRampLength = poolLength / 2;
  const exitRampGeometry = new THREE.BoxGeometry(exitRampWidth, 1, exitRampLength);
  const exitRamp = new THREE.Mesh(exitRampGeometry, rampMaterial);
  exitRamp.position.set(0, -poolDepth + 0.5, poolLength/4); // Position at bottom of pool
  exitRamp.rotation.x = Math.atan2(poolDepth/2, exitRampLength); // Slope upward
  exitRamp.castShadow = true;
  exitRamp.receiveShadow = true;
  poolGroup.add(exitRamp);
  
  // Add ramps to collision objects
  const entryRampBox = new THREE.Box3().setFromObject(entryRamp);
  const exitRampBox = new THREE.Box3().setFromObject(exitRamp);
  collisionObjects.push(entryRampBox);
  collisionObjects.push(exitRampBox);
  roofObjects.push({
    box: entryRampBox,
    position: entryRamp.position.clone(),
    width: entryRampWidth,
    depth: entryRampLength
  });
  roofObjects.push({
    box: exitRampBox,
    position: exitRamp.position.clone(),
    width: exitRampWidth,
    depth: exitRampLength
  });
}

function createUnderwaterCave(poolWidth, poolLength, poolDepth) {
  underwaterCaveGroup = new THREE.Group();
  
  // Create cave entrance at the bottom of the pool
  const caveEntranceGeometry = new THREE.CylinderGeometry(15, 15, 5, 16);
  const caveEntranceMaterial = new THREE.MeshLambertMaterial({ 
    color: 0x1F2937,
    transparent: true,
    opacity: 0.8
  });
  
  const caveEntrance = new THREE.Mesh(caveEntranceGeometry, caveEntranceMaterial);
  caveEntrance.position.set(0, -poolDepth - 2.5, 0); // Below the pool bottom
  caveEntrance.rotation.x = Math.PI / 2; // Lay horizontally
  
  underwaterCaveGroup.add(caveEntrance);
  
  // Create the underwater cave (large spherical chamber)
  const caveGeometry = new THREE.SphereGeometry(60, 32, 32);
  const caveMaterial = new THREE.MeshLambertMaterial({ 
    color: 0x1E40AF,
    transparent: true,
    opacity: 0.3,
    wireframe: false
  });
  
  const cave = new THREE.Mesh(caveGeometry, caveMaterial);
  cave.position.set(0, -poolDepth - 70, 0); // Position below the pool
  
  underwaterCaveGroup.add(cave);
  
  // Add glowing crystals to the cave walls
  for (let i = 0; i < 20; i++) {
    const crystalGeometry = new THREE.ConeGeometry(2, 8, 4);
    const crystalMaterial = new THREE.MeshLambertMaterial({ 
      color: 0x60A5FA,
      emissive: 0x1D4ED8,
      emissiveIntensity: 0.5
    });
    
    const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
    
    // Position crystals randomly on the cave walls
    const phi = Math.acos(2 * Math.random() - 1);
    const theta = Math.random() * Math.PI * 2;
    const radius = 58; // Just inside the cave wall
    
    crystal.position.set(
      radius * Math.sin(phi) * Math.cos(theta),
      radius * Math.sin(phi) * Math.sin(theta) - poolDepth - 70,
      radius * Math.cos(phi)
    );
    
    // Rotate crystals to point outward from the cave center
    crystal.lookAt(0, -poolDepth - 70, 0);
    
    underwaterCaveGroup.add(crystal);
  }
  
  underwaterCaveGroup.position.set(150, 0, 150);
  scene.add(underwaterCaveGroup);
  
  // Add cave to collision objects (but with no gravity physics)
  const caveBox = new THREE.Box3().setFromCenterAndSize(
    new THREE.Vector3(150, -poolDepth - 70, 150),
    new THREE.Vector3(120, 120, 120)
  );
  collisionObjects.push(caveBox);
}

function createMoonBridge() {
  const bridgeGroup = new THREE.Group();
  
  // Cyan bridge material with 70% opacity (rgba(0,255,255,.7))
  const bridgeMaterial = new THREE.MeshLambertMaterial({ 
    color: 0x00FFFF, // Cyan color
    transparent: true,
    opacity: 0.7
  });
  
  const bridgeWidth = 20;
  const bridgeHeight = 5;
  const segments = 200; // More segments for smooth spiral
  
  // Create spiral bridge starting from center with 40-degree incline
  for (let i = 0; i < segments; i++) {
    const t = i / segments;
    const nextT = (i + 1) / segments;
    
    // Spiral parametric equations starting from center
    const spiralTurns = 3; // Number of spiral turns
    const maxRadius = 300; // Maximum spiral radius
    const totalHeight = 750; // Total height from ground to moon
    
    // Spiral coordinates
    const angle = t * Math.PI * 2 * spiralTurns;
    const radius = t * maxRadius;
    
    const x1 = Math.cos(angle) * radius;
    const z1 = Math.sin(angle) * radius;
    const y1 = 5 + t * totalHeight; // Start at ground level, end at moon level
    
    const nextAngle = nextT * Math.PI * 2 * spiralTurns;
    const nextRadius = nextT * maxRadius;
    
    const x2 = Math.cos(nextAngle) * nextRadius;
    const z2 = Math.sin(nextAngle) * nextRadius;
    const y2 = 5 + nextT * totalHeight;
    
    // Calculate segment length and direction
    const dx = x2 - x1;
    const dy = y2 - y1;
    const dz = z2 - z1;
    const segmentLength = Math.sqrt(dx*dx + dy*dy + dz*dz);
    
    // Create bridge segment
    const segmentGeometry = new THREE.BoxGeometry(bridgeWidth, bridgeHeight, segmentLength);
    const segment = new THREE.Mesh(segmentGeometry, bridgeMaterial);
    
    // Position segment at midpoint
    segment.position.set(
      (x1 + x2) / 2,
      (y1 + y2) / 2,
      (z1 + z2) / 2
    );
    
    // Rotate segment to follow the spiral
    segment.rotation.y = Math.atan2(dx, dz);
    segment.rotation.x = -Math.atan2(dy, Math.sqrt(dx*dx + dz*dz));
    
    segment.castShadow = true;
    segment.receiveShadow = true;
    bridgeGroup.add(segment);
    
    // Add segment to collision objects
    const segmentBox = new THREE.Box3().setFromObject(segment);
    collisionObjects.push(segmentBox);
    roofObjects.push({
      box: segmentBox,
      position: segment.position.clone(),
      width: bridgeWidth,
      depth: segmentLength
    });
    
    // Create guardrails for this segment
    createBridgeGuardrails(bridgeGroup, x1, y1, z1, x2, y2, z2, segmentLength);
  }
  
  scene.add(bridgeGroup);
}

function createBridgeGuardrails(bridgeGroup, x1, y1, z1, x2, y2, z2, segmentLength) {
  const railGeometry = new THREE.BoxGeometry(1, 10, segmentLength);
  const railMaterial = new THREE.MeshLambertMaterial({ color: 0x4B5563 });
  
  // Calculate direction vector for the segment
  const dx = x2 - x1;
  const dy = y2 - y1;
  const dz = z2 - z1;
  
  // Calculate perpendicular vector for rail offset
  const length = Math.sqrt(dx*dx + dz*dz);
  const perpX = -dz / length * 10.5; // Offset from bridge center
  const perpZ = dx / length * 10.5;
  
  // Left rail
  const leftRail = new THREE.Mesh(railGeometry, railMaterial);
  leftRail.position.set(
    (x1 + x2) / 2 + perpX,
    (y1 + y2) / 2 + 5,
    (z1 + z2) / 2 + perpZ
  );
  leftRail.rotation.y = Math.atan2(dx, dz);
  leftRail.rotation.x = -Math.atan2(dy, Math.sqrt(dx*dx + dz*dz));
  leftRail.castShadow = true;
  bridgeGroup.add(leftRail);
  
  // Right rail
  const rightRail = new THREE.Mesh(railGeometry, railMaterial);
  rightRail.position.set(
    (x1 + x2) / 2 - perpX,
    (y1 + y2) / 2 + 5,
    (z1 + z2) / 2 - perpZ
  );
  rightRail.rotation.y = Math.atan2(dx, dz);
  rightRail.rotation.x = -Math.atan2(dy, Math.sqrt(dx*dx + dz*dz));
  rightRail.castShadow = true;
  bridgeGroup.add(rightRail);
  
  // Add rails to collision objects
  const leftRailBox = new THREE.Box3().setFromObject(leftRail);
  const rightRailBox = new THREE.Box3().setFromObject(rightRail);
  collisionObjects.push(leftRailBox);
  collisionObjects.push(rightRailBox);
}

function createBoundaryWalls() {
  const wallHeight = 100;
  const wallMaterial = new THREE.MeshLambertMaterial({ 
    color: 0x374151,
    transparent: true,
    opacity: 0.7
  });
  
  // Create walls around the perimeter
  const wallGeometry = new THREE.PlaneGeometry(worldSize, wallHeight);
  
  // North wall
  const northWall = new THREE.Mesh(wallGeometry, wallMaterial);
  northWall.position.set(0, wallHeight/2, -worldBoundary);
  northWall.rotation.x = Math.PI / 2;
  scene.add(northWall);
  
  // South wall
  const southWall = new THREE.Mesh(wallGeometry, wallMaterial);
  southWall.position.set(0, wallHeight/2, worldBoundary);
  southWall.rotation.x = -Math.PI / 2;
  scene.add(southWall);
  
  // East wall
  const eastWall = new THREE.Mesh(wallGeometry, wallMaterial);
  eastWall.position.set(worldBoundary, wallHeight/2, 0);
  eastWall.rotation.x = Math.PI / 2;
  eastWall.rotation.y = Math.PI / 2;
  scene.add(eastWall);
  
  // West wall
  const westWall = new THREE.Mesh(wallGeometry, wallMaterial);
  westWall.position.set(-worldBoundary, wallHeight/2, 0);
  westWall.rotation.x = Math.PI / 2;
  westWall.rotation.y = -Math.PI / 2;
  scene.add(westWall);
}

function createCity() {
  const cityGroup = new THREE.Group();
  const buildingColors = [0x3B82F6, 0xEF4444, 0x10B981, 0xF59E0B, 0x8B5CF6];
  
  // Create buildings with WIDER dimensions, positioned around the center
  const gridSize = 5;
  const spacing = 120; // Increased spacing for wider buildings
  
  for (let x = 0; x < gridSize; x++) {
    for (let z = 0; z < gridSize; z++) {
      // Skip the center position where the bridge starts
      if (x === Math.floor(gridSize/2) && z === Math.floor(gridSize/2)) {
        continue;
      }
      
      // Make buildings WIDER but not as tall
      const width = 40 + Math.random() * 30;  // Increased from 20-35 to 40-70
      const depth = 40 + Math.random() * 30;  // Increased from 20-35 to 40-70
      const height = 20 + Math.random() * 40; // Reduced height for better proportions
      
      const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
      const buildingMaterial = new THREE.MeshLambertMaterial({ 
        color: buildingColors[Math.floor(Math.random() * buildingColors.length)] 
      });
      
      const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
      
      // Position buildings with more spacing, offset from center
      building.position.set(
        (x - gridSize/2) * spacing,
        height / 2,
        (z - gridSize/2) * spacing - 100
      );
      
      building.castShadow = true;
      building.receiveShadow = true;
      cityGroup.add(building);
      buildingObjects.push(building);
      
      // Add building to collision objects
      const buildingBox = new THREE.Box3().setFromObject(building);
      collisionObjects.push(buildingBox);
      
      // Create a solid roof plane for walking on top of the building
      createBuildingRoof(building.position.x, building.position.y + height/2, building.position.z, width, depth);
    }
  }
  
  scene.add(cityGroup);
}

function createBuildingRoof(x, y, z, width, depth) {
  // Create a solid roof plane for collision
  const roofGeometry = new THREE.PlaneGeometry(width, depth);
  const roofMaterial = new THREE.MeshLambertMaterial({ 
    color: 0x1F2937,
    side: THREE.DoubleSide
  });
  
  const roof = new THREE.Mesh(roofGeometry, roofMaterial);
  roof.position.set(x, y + 0.1, z);
  roof.rotation.x = Math.PI / 2;
  
  // Make the roof solid and visible
  roof.receiveShadow = true;
  roof.castShadow = true;
  
  scene.add(roof);
  
  // Add roof to collision objects for walking on
  const roofBox = new THREE.Box3().setFromCenterAndSize(
    new THREE.Vector3(x, y + 0.1, z),
    new THREE.Vector3(width, 0.2, depth)
  );
  roofObjects.push({
    box: roofBox,
    position: new THREE.Vector3(x, y + 0.1, z),
    width: width,
    depth: depth
  });
  
  // Also add the roof to the main collision objects to prevent falling through
  collisionObjects.push(roofBox);
}

function createMoon() {
  const moonGroup = new THREE.Group();
  
  // Create the moon sphere
  const moonGeometry = new THREE.SphereGeometry(100, 32, 32);
  const moonMaterial = new THREE.MeshLambertMaterial({ color: 0xE5E7EB });
  moon = new THREE.Mesh(moonGeometry, moonMaterial);
  
  // Position the moon further left outside the main play area
  moon.position.set(-600, 755, 0);
  moon.castShadow = true;
  moon.receiveShadow = true;
  moonGroup.add(moon);
  
  // Add craters to the moon
  for (let i = 0; i < 20; i++) {
    const craterGeometry = new THREE.SphereGeometry(5 + Math.random() * 15, 16, 16);
    const craterMaterial = new THREE.MeshLambertMaterial({ color: 0x9CA3AF });
    
    const crater = new THREE.Mesh(craterGeometry, craterMaterial);
    
    // Position craters randomly on the moon's surface
    const phi = Math.random() * Math.PI;
    const theta = Math.random() * Math.PI * 2;
    const radius = 100;
    
    crater.position.set(
      radius * Math.sin(phi) * Math.cos(theta),
      radius * Math.sin(phi) * Math.sin(theta),
      radius * Math.cos(phi)
    );
    
    moonGroup.add(crater);
  }
  
  scene.add(moonGroup);
}

function createPlayerAvatar() {
  // Create a group for the entire player (avatar + hover board)
  const group = new THREE.Group();
  
  // Create the silver NFT-shaped hover board - same dimensions as NFT displays (8x8)
  const boardWidth = 8;  // Same as NFT width
  const boardHeight = 0.3; // Thickness
  const boardDepth = 8;    // Same as NFT height
  
  const boardGeometry = new THREE.BoxGeometry(boardWidth, boardHeight, boardDepth);
  const boardMaterial = new THREE.MeshStandardMaterial({ 
    color: 0xC0C0C0, // Silver color
    metalness: 0.9,
    roughness: 0.1,
    emissive: 0x222222
  });
  hoverBoard = new THREE.Mesh(boardGeometry, boardMaterial);
  // Already laying flat due to box geometry orientation
  hoverBoard.castShadow = true;
  hoverBoard.receiveShadow = true;
  group.add(hoverBoard);
  
  // Add green underglow to the hover board - same NFT shape
  const underglowGeometry = new THREE.BoxGeometry(boardWidth + 0.5, 0.1, boardDepth + 0.5);
  const underglowMaterial = new THREE.MeshBasicMaterial({ 
    color: 0x00FF00, // Bright green
    transparent: true,
    opacity: 0.8
  });
  const underglow = new THREE.Mesh(underglowGeometry, underglowMaterial);
  underglow.position.y = -boardHeight/2 - 0.05; // Position below the board
  group.add(underglow);
  
  // Add metallic frame to make it look more like an NFT display
  const frameGeometry = new THREE.BoxGeometry(boardWidth + 0.1, 0.05, boardDepth + 0.1);
  const frameMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x888888,
    metalness: 1.0,
    roughness: 0.1
  });
  const topFrame = new THREE.Mesh(frameGeometry, frameMaterial);
  topFrame.position.y = boardHeight/2 + 0.025;
  group.add(topFrame);
  
  // Create the avatar standing on the board
  let avatar;
  if (selectedAvatar === 'boy') {
    // Create boy avatar - blue color scheme
    const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 8);
    const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x3B82F6 });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    body.position.y = 1.5;
    
    const headGeometry = new THREE.SphereGeometry(0.6, 8, 8);
    const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFCD34D });
    const head = new THREE.Mesh(headGeometry, headMaterial);
    head.position.y = 2.8;
    
    avatar = new THREE.Group();
    avatar.add(body);
    avatar.add(head);
    
  } else if (selectedAvatar === 'girl') {
    // Create girl avatar - pink color scheme
    const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 8);
    const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xEC4899 });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    body.position.y = 1.5;
    
    const headGeometry = new THREE.SphereGeometry(0.6, 8, 8);
    const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFCD34D });
    const head = new THREE.Mesh(headGeometry, headMaterial);
    head.position.y = 2.8;
    
    avatar = new THREE.Group();
    avatar.add(body);
    avatar.add(head);
  }
  
  // Position avatar on top of the hover board
  if (avatar) {
    avatar.position.y = boardHeight/2 + 0.1; // On top of the board
    avatar.castShadow = true;
    group.add(avatar);
  }
  
  // Position the entire group at the starting point (center)
  group.position.set(0, hoverHeight, 0);
  group.castShadow = true;
  scene.add(group);
  
  playerAvatar = group;
}

function initMiniMap() {
  miniMapScene = new THREE.Scene();
  miniMapCamera = new THREE.OrthographicCamera(-worldSize/2, worldSize/2, worldSize/2, -worldSize/2, 0.1, 2000);
  miniMapCamera.position.y = 500;
  miniMapCamera.lookAt(0, 0, 0);
  
  const miniMapCanvas = document.createElement('canvas');
  miniMapCanvas.width = 120;
  miniMapCanvas.height = 120;
  document.getElementById('mini-map').appendChild(miniMapCanvas);
  
  miniMapRenderer = new THREE.WebGLRenderer({ 
    canvas: miniMapCanvas,
    antialias: false 
  });
  miniMapRenderer.setSize(120, 120);
  miniMapRenderer.setClearColor(0x000000, 0.5);
  
  // Add ground to mini-map
  const groundGeometry = new THREE.PlaneGeometry(worldSize, worldSize);
  const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x4ADE80 });
  const ground = new THREE.Mesh(groundGeometry, groundMaterial);
  ground.rotation.x = -Math.PI / 2;
  miniMapScene.add(ground);
  
  // Add pool indicator to mini-map
  const poolGeometry = new THREE.PlaneGeometry(80, 80);
  const poolMaterial = new THREE.MeshBasicMaterial({ color: 0x1E40AF });
  const poolIndicator = new THREE.Mesh(poolGeometry, poolMaterial);
  poolIndicator.position.set(150, 0, 150);
  poolIndicator.rotation.x = -Math.PI / 2;
  miniMapScene.add(poolIndicator);
  
  // Add bridge indicator to mini-map (spiral pattern)
  const bridgeIndicatorGeometry = new THREE.RingGeometry(0, 300, 36);
  const bridgeIndicatorMaterial = new THREE.MeshBasicMaterial({ 
    color: 0x00FFFF,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.3
  });
  const bridgeIndicator = new THREE.Mesh(bridgeIndicatorGeometry, bridgeIndicatorMaterial);
  bridgeIndicator.rotation.x = -Math.PI / 2;
  miniMapScene.add(bridgeIndicator);
  
  // Add player indicator
  const playerGeometry = new THREE.CircleGeometry(10, 8);
  const playerMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
  const playerIndicator = new THREE.Mesh(playerGeometry, playerMaterial);
  playerIndicator.rotation.x = -Math.PI / 2;
  miniMapScene.add(playerIndicator);
  
  // Add NFT indicators
  const nftIndicatorGeometry = new THREE.CircleGeometry(8, 6);
  const nftIndicatorMaterial = new THREE.MeshBasicMaterial({ color: 0x3B82F6 });
  
  window.updateMiniMap = function() {
    // Update player position
    playerIndicator.position.x = playerAvatar.position.x;
    playerIndicator.position.z = playerAvatar.position.z;
    
    // Update player avatar rotation based on camera angle
    if (playerAvatar) {
      playerAvatar.rotation.y = cameraAngle + Math.PI;
    }
    
    // Update location info
    updateLocationInfo();
    
    // Clear previous NFT indicators
    miniMapScene.children.forEach((child, index) => {
      if (child.userData && child.userData.isNFTIndicator) {
        miniMapScene.children.splice(index, 1);
      }
    });
    
    // Add current NFT indicators
    nftObjects.forEach(nft => {
      const indicator = new THREE.Mesh(nftIndicatorGeometry, nftIndicatorMaterial);
      indicator.position.x = nft.position.x;
      indicator.position.z = nft.position.z;
      indicator.rotation.x = -Math.PI / 2;
      indicator.userData = { isNFTIndicator: true };
      miniMapScene.add(indicator);
    });
    
    miniMapRenderer.render(miniMapScene, miniMapCamera);
  };
}

function updateLocationInfo() {
  const locationInfo = document.getElementById('location-info');
  const x = playerAvatar.position.x;
  const z = playerAvatar.position.z;
  const y = playerAvatar.position.y;
  
  // Check if player is in the underwater cave
  if (isInUnderwaterCave) {
    locationInfo.textContent = "Location: Underwater Cave (Zero Gravity)";
  }
  // Check if player is in the swimming pool
  else if (isInWater) {
    locationInfo.textContent = "Location: Swimming Pool (Floating)";
  }
  // Check if player is on the moon
  else if (y > 600) {
    locationInfo.textContent = "Location: Moon Surface (Floating)";
  }
  // Check if player is on the bridge
  else if (y > 50) {
    locationInfo.textContent = "Location: Moon Bridge (Floating)";
  }
  // Check if player is on a building roof
  else if (playerOnRoof) {
    locationInfo.textContent = "Location: Building Roof (Floating)";
  }
  // Check if player is in the city
  else if (x > -200 && x < 200 && z > -200 && z < 200) {
    locationInfo.textContent = "Location: City Center (Floating)";
  }
  // Otherwise in the grass fields
  else {
    locationInfo.textContent = "Location: Grass Fields (Floating)";
  }
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

// COLLISION DETECTION FOR FLOATING BOARD
function checkCollisions(newPosition) {
  // Update player collider position and size for floating board
  playerCollider.setFromCenterAndSize(
    new THREE.Vector3(newPosition.x, newPosition.y, newPosition.z),
    playerSize
  );
  
  // Check for collisions with all collision objects
  for (let i = 0; i < collisionObjects.length; i++) {
    if (playerCollider.intersectsBox(collisionObjects[i])) {
      return true; // Collision detected
    }
  }
  
  return false; // No collision
}

function animate() {
  requestAnimationFrame(animate);
  
  const time = performance.now();
  const delta = (time - prevTime) / 1000;
  hoverTime += delta;
  
  // Handle movement
  if ((controls && controls.isLocked) || isMobile) {
    const moveSpeed = 200.0 * delta;
    
    // Store current position for collision detection
    const currentPosition = playerAvatar.position.clone();
    
    // Calculate new position based on movement
    const newPosition = currentPosition.clone();
    
    // Calculate movement direction based on camera angle
    const forward = new THREE.Vector3(
      Math.sin(cameraAngle),
      0,
      Math.cos(cameraAngle)
    );
    const right = new THREE.Vector3(
      Math.sin(cameraAngle + Math.PI/2),
      0,
      Math.cos(cameraAngle + Math.PI/2)
    );
    
    if (moveForward) {
      newPosition.add(forward.clone().multiplyScalar(moveSpeed));
    }
    if (moveBackward) {
      newPosition.sub(forward.clone().multiplyScalar(moveSpeed));
    }
    if (moveLeft) {
      newPosition.sub(right.clone().multiplyScalar(moveSpeed));
    }
    if (moveRight) {
      newPosition.add(right.clone().multiplyScalar(moveSpeed));
    }
    
    // Apply floating physics - gentle vertical movement
    const hoverBob = Math.sin(hoverTime * hoverBobSpeed) * hoverBobAmount;
    newPosition.y = hoverHeight + hoverBob;
    
    // Apply jump physics if jumping
    if (velocity.y !== 0) {
      velocity.y -= 9.8 * 100.0 * delta;
      newPosition.y += (velocity.y * delta);
      
      // Reset jump when back to normal hover height
      if (newPosition.y <= hoverHeight + hoverBob && velocity.y < 0) {
        velocity.y = 0;
        canJump = true;
      }
    }
    
    // Check if player is in the swimming pool (adjusted for new pool position)
    const poolBounds = new THREE.Box3(
      new THREE.Vector3(150 - 40, -15, 150 - 40),
      new THREE.Vector3(150 + 40, 0, 150 + 40)
    );
    isInWater = poolBounds.containsPoint(playerAvatar.position);
    
    // Check if player is in the underwater cave (adjusted for new position)
    const caveBounds = new THREE.Box3(
      new THREE.Vector3(150 - 60, -150, 150 - 60),
      new THREE.Vector3(150 + 60, -90, 150 + 60)
    );
    isInUnderwaterCave = caveBounds.containsPoint(playerAvatar.position);
    
    // Apply underwater physics if in water - FIXED: Now gravity pulls you down
    if (isInWater) {
      // Apply downward gravity in water (pulls you to the bottom)
      velocity.y -= 9.8 * 50.0 * delta; // Reduced gravity for water resistance
      newPosition.y += (velocity.y * delta);
      
      // If at bottom of pool, stop falling
      if (playerAvatar.position.y <= -15) {
        velocity.y = 0;
        newPosition.y = -15;
        canJump = true;
      }
    }
    
    // If in the underwater cave, apply ZERO GRAVITY physics
    if (isInUnderwaterCave) {
      // Zero gravity - no downward force
      velocity.y *= 0.98; // Very slight damping to prevent infinite floating
      
      // Allow free floating movement in all directions with zero gravity
      if (moveForward) {
        newPosition.add(forward.clone().multiplyScalar(moveSpeed * 0.5));
      }
      if (moveBackward) {
        newPosition.sub(forward.clone().multiplyScalar(moveSpeed * 0.5));
      }
      if (moveLeft) {
        newPosition.sub(right.clone().multiplyScalar(moveSpeed * 0.5));
      }
      if (moveRight) {
        newPosition.add(right.clone().multiplyScalar(moveSpeed * 0.5));
      }
      
      // In zero gravity, jumping should propel you upward
      if (canJump && velocity.y === 0) {
        // Allow upward movement with space bar in zero gravity
        velocity.y += 200 * delta;
      }
    }
    
    // Check for collisions before updating position
    if (!checkCollisions(newPosition)) {
      // No collision, update position
      playerAvatar.position.copy(newPosition);
    } else {
      // Collision detected, revert to original position
      playerAvatar.position.copy(currentPosition);
    }
    
    // Prevent going outside world boundaries
    if (playerAvatar.position.x > worldBoundary) {
      playerAvatar.position.x = worldBoundary;
    }
    if (playerAvatar.position.x < -worldBoundary) {
      playerAvatar.position.x = -worldBoundary;
    }
    if (playerAvatar.position.z > worldBoundary) {
      playerAvatar.position.z = worldBoundary;
    }
    if (playerAvatar.position.z < -worldBoundary) {
      playerAvatar.position.z = -worldBoundary;
    }
  }
  
  // Handle look for mobile
  if (isMobile && (lookX !== 0 || lookY !== 0)) {
    targetCameraAngle -= lookX * 0.01;
    // Limit vertical camera movement for third-person
    cameraHeight = Math.max(5, Math.min(20, cameraHeight - lookY * 0.1));
  }
  
  // Update third-person camera
  updateThirdPersonCamera();
  
  // Update raycaster for object interaction
  raycaster.set(camera.position, camera.getWorldDirection(new THREE.Vector3()));
  
  const intersects = raycaster.intersectObjects(nftObjects);
  
  if (intersects.length > 0) {
    if (currentIntersected !== intersects[0].object) {
      // Reset previous intersection
      if (currentIntersected) {
        currentIntersected.material.emissive.setHex(currentIntersected.userData.originalEmissive);
      }
      
      // Set new intersection
      currentIntersected = intersects[0].object;
      currentIntersected.userData.originalEmissive = currentIntersected.material.emissive.getHex();
      currentIntersected.material.emissive.setHex(0x3b82f6);
      
      // Change cursor to pointer
      if (!isMobile) {
        document.body.style.cursor = 'pointer';
      }
    }
  } else {
    if (currentIntersected) {
      currentIntersected.material.emissive.setHex(currentIntersected.userData.originalEmissive);
      currentIntersected = null;
      if (!isMobile) {
        document.body.style.cursor = 'auto';
      }
    }
  }
  
  // Update mini-map
  if (window.updateMiniMap) {
    window.updateMiniMap();
  }
  
  prevTime = time;
  renderer.render(scene, camera);
}

function createNFTPlane(nftData, position, isMoonNFT = false, isUnderwaterNFT = false) {
  // Create a plane for the NFT image
  const geometry = new THREE.PlaneGeometry(8, 8);
  
  // Create texture loader
  const textureLoader = new THREE.TextureLoader();
  const texture = textureLoader.load(nftData.image_url, function() {
    // Texture loaded
  });
  
  const material = new THREE.MeshStandardMaterial({ 
    map: texture,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.9
  });
  
  const plane = new THREE.Mesh(geometry, material);
  plane.position.set(position.x, position.y, position.z);
  
  // Rotate to face a random direction
  plane.rotation.y = Math.random() * Math.PI * 2;
  
  // Store NFT data for interaction
  plane.userData.nftData = nftData;
  plane.userData.originalEmissive = 0x000000;
  
  scene.add(plane);
  nftObjects.push(plane);
  
  // Add a subtle glow effect - different color for different locations
  const glowGeometry = new THREE.PlaneGeometry(8.5, 8.5);
  let glowColor;
  if (isMoonNFT) {
    glowColor = 0xFFD700; // Gold for moon
  } else if (isUnderwaterNFT) {
    glowColor = 0x00FFFF; // Cyan for underwater
  } else {
    glowColor = 0x3b82f6; // Blue for earth
  }
  
  const glowMaterial = new THREE.MeshBasicMaterial({ 
    color: glowColor,
    transparent: true,
    opacity: 0.4,
    side: THREE.DoubleSide
  });
  const glow = new THREE.Mesh(glowGeometry, glowMaterial);
  glow.position.copy(plane.position);
  glow.rotation.copy(plane.rotation);
  scene.add(glow);
  
  // Make glow part of the NFT object for interaction
  plane.userData.glow = glow;
}

function openNFTModal(nftData) {
  document.getElementById('modal-image').src = nftData.image_url;
  document.getElementById('modal-title').textContent = `${nftData.collection || 'Untitled'} #${nftData.token_id ?? ''}`;
  document.getElementById('modal-description').textContent = nftData.description || 'No description available';
  document.getElementById('modal-price').textContent = nftData.price_eth ?? 'N/A';
  
  let buttons = "";
  if (!account) {
    buttons = "<p>üîí Connect wallet to interact.</p>";
  } else if (nftData.owner?.toLowerCase() === account.toLowerCase()) {
    buttons = `
      <button onclick="sellNFT(${nftData.token_id})">Sell</button>
      <button onclick="transferNFT(${nftData.token_id})">Transfer ($6 fee)</button>
    `;
  } else {
    buttons = `<button onclick="buyNFT(${nftData.token_id}, ${nftData.price_eth || 0})">Buy ($6 fee)</button>`;
  }
  
  document.getElementById('modal-actions').innerHTML = buttons;
  document.getElementById('nft-modal').style.display = 'block';
}

document.getElementById('close-modal').addEventListener('click', function() {
  document.getElementById('nft-modal').style.display = 'none';
});

// Handle click/tap on NFT
document.addEventListener('click', function onClick(event) {
  if (((!isMobile && controls && controls.isLocked) || (isMobile && currentIntersected)) && currentIntersected) {
    const nftData = currentIntersected.userData.nftData;
    openNFTModal(nftData);
  }
});

/* ==============================
   CONNECT WALLET (MetaMask + WalletConnect)
============================== */
async function connectWallet() {
  try {
    if (window.ethereum) {
      web3 = new Web3(window.ethereum);
      const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
      account = accounts[0];
    } else {
      const provider = new WalletConnectProvider.default({
        rpc: { 1: "https://mainnet.infura.io/v3/d71dd33696d449e488a88bdc02a6093c" },
      });
      await provider.enable();
      web3 = new Web3(provider);
      const accounts = await web3.eth.getAccounts();
      account = accounts[0];
    }

    document.getElementById("walletStatus").innerText =
      `‚úÖ Connected: ${account.slice(0, 6)}...${account.slice(-4)}`;

    nftContract = new web3.eth.Contract(NFT_ABI, NFT_CONTRACT_ADDRESS);
    if (avatarSelection.style.display === 'none') {
      loadNFTs();
    }

  } catch (err) {
    console.error(err);
    alert("Failed to connect wallet.");
  }
}

document.getElementById("connectBtn").addEventListener("click", connectWallet);

/* ==============================
   LOAD NFTs
============================== */
async function loadNFTs() {
  const { data, error } = await client.from("nfts").select("*").order("created_at", { ascending: false });

  if (error) {
    console.error(error);
    return;
  }
  
  if (!data || data.length === 0) {
    return;
  }

  // Clear existing NFTs
  nftObjects.forEach(obj => {
    scene.remove(obj);
    if (obj.userData.glow) {
      scene.remove(obj.userData.glow);
    }
  });
  nftObjects = [];
  
  // Split NFTs between Earth, Moon, Bridge, and Underwater Cave
  const totalNFTs = data.length;
  const earthCount = Math.floor(totalNFTs * 0.35); // 35% on Earth (reduced from 50%)
  const moonCount = Math.floor(totalNFTs * 0.25); // 25% on Moon
  const underwaterCount = Math.floor(totalNFTs * 0.15); // 15% in underwater cave
  const bridgeCount = totalNFTs - earthCount - moonCount - underwaterCount; // 25% on Bridge
  
  const earthNFTs = data.slice(0, earthCount);
  const moonNFTs = data.slice(earthCount, earthCount + moonCount);
  const underwaterNFTs = data.slice(earthCount + moonCount, earthCount + moonCount + underwaterCount);
  const bridgeNFTs = data.slice(earthCount + moonCount + underwaterCount);
  
  // Position Earth NFTs randomly across the terrain
  earthNFTs.forEach((nft, index) => {
    // Create positions in a circular pattern
    const angle = (index / earthNFTs.length) * Math.PI * 2;
    const radius = 100 + Math.random() * 300;
    
    const x = Math.cos(angle) * radius;
    const z = Math.sin(angle) * radius;
    
    // Add some randomness to positions
    const randomOffsetX = (Math.random() - 0.5) * 50;
    const randomOffsetZ = (Math.random() - 0.5) * 50;
    
    // Get terrain height at this position
    let terrainHeight = 5;
    if (Math.sqrt((x + randomOffsetX)**2 + (z + randomOffsetZ)**2) > 200) {
      terrainHeight = 20 + Math.random() * 50;
    } else if (x > -200 && x < 200 && z > -200 && z < 200) {
      terrainHeight = 15 + Math.random() * 30;
    }
    
    // Position NFTs at floating height
    createNFTPlane(nft, { 
      x: x + randomOffsetX, 
      y: terrainHeight + 8, // Higher for floating players
      z: z + randomOffsetZ 
    }, false, false);
  });
  
  // Position Moon NFTs on the moon surface
  moonNFTs.forEach((nft, index) => {
    // Position NFTs randomly on the moon's surface
    const phi = Math.acos(2 * Math.random() - 1);
    const theta = Math.random() * Math.PI * 2;
    const radius = 110;
    
    const x = radius * Math.sin(phi) * Math.cos(theta);
    const y = radius * Math.sin(phi) * Math.sin(theta);
    const z = radius * Math.cos(phi);
    
    // Offset by moon position (moved left)
    createNFTPlane(nft, { 
      x: moon.position.x + x, 
      y: moon.position.y + y, 
      z: moon.position.z + z 
    }, true, false);
  });
  
  // Position Underwater NFTs in the underwater cave
  underwaterNFTs.forEach((nft, index) => {
    // Position NFTs randomly in the underwater cave
    const phi = Math.acos(2 * Math.random() - 1);
    const theta = Math.random() * Math.PI * 2;
    const radius = 50; // Inside the cave
    
    const x = radius * Math.sin(phi) * Math.cos(theta);
    const y = radius * Math.sin(phi) * Math.sin(theta) - 120; // Center of cave
    const z = radius * Math.cos(phi);
    
    createNFTPlane(nft, { 
      x: 150 + x, // Offset by pool position
      y: y, 
      z: 150 + z  // Offset by pool position
    }, false, true);
  });
  
  // Position Bridge NFTs along the spiral bridge
  bridgeNFTs.forEach((nft, index) => {
    const t = index / bridgeNFTs.length;
    
    // Use same spiral equations as the bridge
    const spiralTurns = 3;
    const maxRadius = 300;
    const totalHeight = 750;
    
    const angle = t * Math.PI * 2 * spiralTurns;
    const radius = t * maxRadius;
    
    const x = Math.cos(angle) * radius;
    const z = Math.sin(angle) * radius;
    const y = 5 + t * totalHeight + 3; // Slightly above bridge surface
    
    createNFTPlane(nft, { 
      x: x, 
      y: y, 
      z: z 
    }, false, false);
  });
}

/* ==============================
   BUY NFT
============================== */
async function buyNFT(tokenId, priceEth) {
  if (!account) return alert("Connect wallet first.");
  try {
    const totalEth = web3.utils.toWei((Number(priceEth) + 6/1000).toString(), 'ether');
    await web3.eth.sendTransaction({ from: account, to: RECEIVER_ADDRESS, value: totalEth });

    await client.from("nfts").update({ owner: account, sold: true }).eq("token_id", tokenId);
    alert("‚úÖ NFT purchased! Payment sent.");
    loadNFTs();
    document.getElementById('nft-modal').style.display = 'none';
  } catch(err) { console.error(err); alert("Buy failed: " + err.message); }
}

/* ==============================
   SELL NFT
============================== */
async function sellNFT(tokenId) {
  if (!account) return alert("Connect wallet first.");
  const priceEth = prompt("Enter sale price in ETH:");
  if (!priceEth) return;
  await client.from("nfts").update({ sold: false, price_eth: priceEth, owner: account }).eq("token_id", tokenId);
  alert("‚úÖ NFT listed for sale!");
  loadNFTs();
  document.getElementById('nft-modal').style.display = 'none';
}

/* ==============================
   TRANSFER NFT
============================== */
async function transferNFT(tokenId) {
  if (!account) return alert("Connect wallet first.");
  const recipient = prompt("Enter recipient wallet address:");
  if (!recipient) return;
  try {
    const feeEth = web3.utils.toWei((6/1000).toString(), 'ether');
    await web3.eth.sendTransaction({ from: account, to: RECEIVER_ADDRESS, value: feeEth });

    await nftContract.methods.safeTransferFrom(account, recipient, tokenId).send({ from: account });

    await client.from("nfts").update({ owner: recipient }).eq("token_id", tokenId);
    alert("‚úÖ NFT transferred! Fee sent.");
    loadNFTs();
    document.getElementById('nft-modal').style.display = 'none';
  } catch(err) { console.error(err); alert("Transfer failed: " + err.message); }
}

// The 3D scene will be initialized after avatar selection
</script>

</body>
</html>
