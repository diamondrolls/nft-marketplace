<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>üíé 3D NFT Universe - Multiplayer</title>

<!-- Supabase & Web3.js & WalletConnect -->
<script src="https://unpkg.com/@supabase/supabase-js"></script>
<script src="https://cdn.jsdelivr.net/npm/web3/dist/web3.min.js"></script>
<script src="https://unpkg.com/@walletconnect/web3-provider@1.8.0/dist/umd/index.min.js"></script>

<!-- Three.js for 3D rendering -->
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>

<style>
  :root {
    --bg: #f8fafc;
    --card-bg: #ffffff;
    --text-dark: #1e293b;
    --text-light: #475569;
    --accent: #3b82f6;
    --shadow: 0 4px 12px rgba(0,0,0,0.08);
  }
  
  .homepage{
    border-style: outset;
    width: 120px;
    height: 45px;
    background-image: url('https://i.pinimg.com/564x/35/38/ed/3538edbdb531c7fe3bb387ead4b398b0.jpg');
    background-size: 120px 45px;
    border-radius: 50%;
    text-align: center;
    line-height: 45px;
    color: white;
    font-weight: bold;
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 100;
    font-size: 0.8rem;
  }
  
  * { box-sizing: border-box; }
  body { 
    font-family: system-ui, sans-serif; 
    background: var(--bg); 
    margin: 0; 
    padding: 0; 
    color: var(--text-dark); 
    overflow: hidden;
    touch-action: none;
  }
  
  header { 
    background: var(--card-bg); 
    text-align: center; 
    padding: 12px 8px; 
    border-bottom: 1px solid #e2e8f0; 
    position: absolute; 
    top: 0; 
    width: 100%; 
    z-index: 10; 
  }
  
  h1 { font-size: 1.4rem; margin: 0; }
  #walletStatus { margin-top: 6px; font-size: 0.8rem; color: var(--text-light); }
  #connectBtn { 
    margin-top: 4px; 
    padding: 4px 8px;
    font-size: 0.8rem;
  }
  
  #canvas-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }
  
  #instructions {
    position: absolute;
    bottom: 10px;
    left: 0;
    width: 100%;
    text-align: center;
    color: white;
    background-color: rgba(0,0,0,0.7);
    padding: 8px;
    z-index: 100;
    font-size: 0.8rem;
  }
  
  #mobile-controls {
    position: absolute;
    bottom: 80px;
    right: 10px;
    z-index: 100;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  
  .mobile-btn {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: rgba(59, 130, 246, 0.7);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.2rem;
    font-weight: bold;
    user-select: none;
    -webkit-user-select: none;
    touch-action: manipulation;
  }
  
  #look-controls {
    position: absolute;
    bottom: 80px;
    left: 10px;
    width: 120px;
    height: 120px;
    z-index: 100;
    background: rgba(0,0,0,0.2);
    border-radius: 50%;
    touch-action: none;
  }
  
  #nft-modal {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--card-bg);
    border-radius: 16px;
    box-shadow: var(--shadow);
    padding: 20px;
    z-index: 1000;
    max-width: 90%;
    width: 350px;
    max-height: 80vh;
    overflow-y: auto;
  }
  
  #nft-modal img {
    width: 100%;
    height: 200px;
    object-fit: cover;
    display: block;
    border-radius: 8px;
    margin-bottom: 15px;
  }
  
  #nft-modal h3 {
    margin: 8px 0 4px;
    font-size: 1.1rem;
    font-weight: 600;
  }
  
  #nft-modal p {
    margin: 4px 0;
    font-size: 0.9rem;
    color: var(--text-light);
  }
  
  .nft-actions {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-top: 10px;
  }
  
  button {
    border: none;
    background: var(--accent);
    color: white;
    padding: 8px 12px;
    border-radius: 8px;
    font-size: 0.85rem;
    cursor: pointer;
    transition: background 0.2s;
  }
  
  button:hover {
    background: #2563eb;
  }
  
  #close-modal {
    position: absolute;
    top: 10px;
    right: 10px;
    background: #ef4444;
    width: 30px;
    height: 30px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  #close-modal:hover {
    background: #dc2626;
  }
  
  #mini-map {
    position: absolute;
    top: 70px;
    right: 10px;
    width: 120px;
    height: 120px;
    background: rgba(0,0,0,0.5);
    border-radius: 8px;
    z-index: 100;
    border: 2px solid white;
  }
  
  #location-info {
    position: absolute;
    top: 70px;
    left: 10px;
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 8px 12px;
    border-radius: 8px;
    font-size: 0.8rem;
    z-index: 100;
    max-width: 200px;
  }
  
  #nft-counter {
    position: absolute;
    top: 120px;
    left: 10px;
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 8px 12px;
    border-radius: 8px;
    font-size: 0.8rem;
    z-index: 100;
    max-width: 200px;
  }
  
  #avatar-selection {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.8);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 2000;
  }
  
  #avatar-selection h2 {
    color: white;
    margin-bottom: 30px;
    font-size: 1.8rem;
  }
  
  .avatar-options {
    display: flex;
    gap: 30px;
    flex-wrap: wrap;
    justify-content: center;
  }
  
  .avatar-option {
    width: 200px;
    height: 300px;
    border-radius: 12px;
    overflow: hidden;
    cursor: pointer;
    transition: transform 0.3s, box-shadow 0.3s;
    border: 3px solid transparent;
  }
  
  .avatar-option:hover {
    transform: scale(1.05);
    box-shadow: 0 10px 20px rgba(0,0,0,0.3);
  }
  
  .avatar-option.selected {
    border-color: var(--accent);
    box-shadow: 0 0 20px var(--accent);
  }
  
  #boy-avatar {
    background-image: url('https://raw.githubusercontent.com/diamondrolls/images/main/431BBB65-C6F8-49BC-B882-EA5BBE885462.png');
    background-size: cover;
    background-position: center;
  }
  
  #girl-avatar {
    background-image: url('https://raw.githubusercontent.com/diamondrolls/images/main/3974D02C-0D5B-4F49-8597-5185D48FB2A1.png');
    background-size: cover;
    background-position: center;
  }
  
  #confirm-avatar {
    margin-top: 30px;
    padding: 12px 24px;
    font-size: 1.1rem;
    background: var(--accent);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.2s;
  }
  
  #confirm-avatar:hover {
    background: #2563eb;
  }

  /* Multiplayer UI */
  #multiplayer-panel {
    position: absolute;
    top: 70px;
    right: 140px;
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 8px 12px;
    border-radius: 8px;
    font-size: 0.8rem;
    z-index: 100;
    max-width: 200px;
  }

  #multiplayer-panel h3 {
    margin: 0 0 8px 0;
    font-size: 0.9rem;
    text-align: center;
  }

  .player-item {
    display: flex;
    align-items: center;
    margin-bottom: 5px;
    padding: 4px;
    border-radius: 4px;
    background: rgba(255,255,255,0.1);
  }

  .player-color {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    margin-right: 8px;
  }

  .player-name {
    flex: 1;
    font-size: 0.75rem;
  }

  #chat-panel {
    position: absolute;
    bottom: 200px;
    left: 10px;
    width: 300px;
    max-height: 200px;
    background: rgba(0,0,0,0.7);
    border-radius: 8px;
    z-index: 100;
    display: flex;
    flex-direction: column;
  }

  #chat-messages {
    flex: 1;
    overflow-y: auto;
    padding: 8px;
    color: white;
    font-size: 0.8rem;
  }

  .chat-message {
    margin-bottom: 5px;
    word-wrap: break-word;
  }

  .chat-sender {
    font-weight: bold;
    color: #3b82f6;
  }

  #chat-input-container {
    display: flex;
    padding: 8px;
    border-top: 1px solid rgba(255,255,255,0.2);
  }

  #chat-input {
    flex: 1;
    padding: 4px 8px;
    border: none;
    border-radius: 4px;
    background: rgba(255,255,255,0.9);
    font-size: 0.8rem;
  }

  #chat-send {
    margin-left: 5px;
    padding: 4px 8px;
    background: var(--accent);
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.8rem;
  }
  
  @media (max-width: 500px) { 
    header h1 { font-size: 1.2rem; } 
    #instructions {
      font-size: 0.7rem;
      bottom: 5px;
    }
    #mobile-controls {
      bottom: 60px;
    }
    #look-controls {
      bottom: 60px;
      width: 100px;
      height: 100px;
    }
    .mobile-btn {
      width: 45px;
      height: 45px;
      font-size: 1rem;
    }
    #mini-map {
      width: 100px;
      height: 100px;
      top: 60px;
    }
    .avatar-option {
      width: 150px;
      height: 225px;
    }
    #avatar-selection h2 {
      font-size: 1.4rem;
    }
    #location-info {
      top: 60px;
      font-size: 0.7rem;
      max-width: 150px;
    }
    #nft-counter {
      top: 110px;
      font-size: 0.7rem;
    }
    #multiplayer-panel {
      top: 60px;
      right: 120px;
      max-width: 150px;
    }
    #chat-panel {
      width: 250px;
      bottom: 150px;
    }
  }
</style>
</head>
<body>

<header>
  <h1>NFT Universe Explorer - Multiplayer</h1>
  <div id="walletStatus">Not connected</div>
  <button id="connectBtn">Connect Wallet</button>
</header>

<a href='https://diamondrolls.github.io/thepremiumway/'> 
  <div class="homepage">Home</div>
</a>

<div id="canvas-container"></div>

<div id="instructions">
  <div id="desktop-instructions">Click to lock pointer and navigate with WASD keys. Move mouse to look around. Press SPACE to jump. Press T to chat. Explore NFTs in the vertical column and bridge!</div>
  <div id="mobile-instructions" style="display:none;">Use controls to move and look around. Explore NFTs in the vertical column and bridge!</div>
</div>

<div id="location-info">
  Location: Starting Area
</div>

<div id="nft-counter">
  NFTs Loaded: <span id="nft-count">0</span>
</div>

<!-- Multiplayer UI -->
<div id="multiplayer-panel">
  <h3>Online Players (<span id="player-count">1</span>)</h3>
  <div id="players-list">
    <div class="player-item">
      <div class="player-color" style="background-color: #3b82f6;"></div>
      <div class="player-name">You</div>
    </div>
  </div>
</div>

<div id="chat-panel">
  <div id="chat-messages"></div>
  <div id="chat-input-container">
    <input type="text" id="chat-input" placeholder="Type a message...">
    <button id="chat-send">Send</button>
  </div>
</div>

<div id="mobile-controls">
  <div class="mobile-btn" id="forward-btn">‚Üë</div>
  <div style="display:flex; gap:10px;">
    <div class="mobile-btn" id="left-btn">‚Üê</div>
    <div class="mobile-btn" id="backward-btn">‚Üì</div>
    <div class="mobile-btn" id="right-btn">‚Üí</div>
  </div>
  <div class="mobile-btn" id="jump-btn" style="background: rgba(34, 197, 94, 0.7);">‚§¥</div>
</div>

<div id="look-controls"></div>

<div id="mini-map"></div>

<div id="nft-modal">
  <button id="close-modal">X</button>
  <img id="modal-image" src="" alt="NFT" />
  <div class="nft-info">
    <h3 id="modal-title"></h3>
    <p id="modal-description"></p>
    <p><strong>Price:</strong> <span id="modal-price"></span> ETH</p>
    <div class="nft-actions" id="modal-actions"></div>
  </div>
</div>

<div id="avatar-selection">
  <h2>Choose Your Explorer</h2>
  <div class="avatar-options">
    <div class="avatar-option" id="boy-avatar" data-avatar="boy"></div>
    <div class="avatar-option" id="girl-avatar" data-avatar="girl"></div>
  </div>
  <div style="margin-top: 20px;">
    <input type="text" id="player-name" placeholder="Enter your display name" maxlength="15" style="padding: 8px; border-radius: 4px; border: 1px solid #ccc; width: 200px;">
  </div>
  <button id="confirm-avatar">Start Exploring</button>
</div>

<script>
/* ==============================
   CONFIGURATION
============================== */
const supabaseUrl = "https://fjtzodjudyctqacunlqp.supabase.co";
const supabaseKey = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZqdHpvZGp1ZHljdHFhY3VubHFwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgwNjA2OTQsImV4cCI6MjA3MzYzNjY5NH0.qR9RBsecfGUfKnbWgscmxloM-oEClJs_bo5YWoxFoE4";
const client = supabase.createClient(supabaseUrl, supabaseKey);

const NFT_CONTRACT_ADDRESS = "0x3ed4474a942d885d5651c8c56b238f3f4f524a5c";
const NFT_ABI = [
  { "constant":true,"inputs":[{"name":"tokenId","type":"uint256"}],"name":"ownerOf","outputs":[{"name":"","type":"address"}],"type":"function" },
  { "constant":false,"inputs":[{"name":"from","type":"address"},{"name":"to","type":"address"},{"name":"tokenId","type":"uint256"}],"name":"safeTransferFrom","outputs":[],"type":"function" }
];
const RECEIVER_ADDRESS = "0xaE0C180e071eE288B2F2f6ff6edaeF014678fFB7";

let web3, account, nftContract;

// Redirect to login page if not logged in
client.auth.getSession().then(({ data }) => {
  if (!data.session) {
    window.location.href = 'https://diamondrolls.github.io/play/';
  }
});

/* ==============================
   WEBRTC MULTIPLAYER
============================== */
class WebRTCMultiplayer {
  constructor() {
    this.peers = new Map();
    this.otherPlayers = new Map();
    this.roomId = 'nft-universe-main';
    this.playerId = this.generatePlayerId();
    this.playerName = 'Explorer';
    this.playerColor = 0x3B82F6;
    this.signalingChannel = null;
    this.dataChannels = new Map();
    
    this.init();
  }

  generatePlayerId() {
    if (!localStorage.getItem('playerId')) {
      localStorage.setItem('playerId', 'player-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9));
    }
    return localStorage.getItem('playerId');
  }

  async init() {
    this.setupSignaling();
    this.setupChat();
    
    // Set player name from input if available
    const nameInput = document.getElementById('player-name');
    if (nameInput) {
      nameInput.addEventListener('input', (e) => {
        this.playerName = e.target.value.trim() || 'Explorer';
      });
    }
  }

  setupSignaling() {
    // Use BroadcastChannel for same-origin communication
    try {
      this.signalingChannel = new BroadcastChannel('nft-universe-webrtc');
      
      this.signalingChannel.addEventListener('message', async (event) => {
        const message = event.data;
        
        if (message.roomId !== this.roomId || message.playerId === this.playerId) return;
        
        switch (message.type) {
          case 'player-join':
            await this.handlePlayerJoin(message);
            break;
          case 'offer':
            await this.handleOffer(message);
            break;
          case 'answer':
            await this.handleAnswer(message);
            break;
          case 'ice-candidate':
            await this.handleIceCandidate(message);
            break;
          case 'player-data':
            this.handlePlayerData(message);
            break;
          case 'player-left':
            this.handlePlayerLeft(message);
            break;
        }
      });

      // Announce our presence
      this.broadcastSignal({
        type: 'player-join',
        playerId: this.playerId,
        playerData: this.getPlayerData()
      });

    } catch (error) {
      console.log('BroadcastChannel not supported, using localStorage fallback');
      this.setupLocalStorageSignaling();
    }
  }

  setupLocalStorageSignaling() {
    // Fallback for browsers without BroadcastChannel
    setInterval(() => {
      const signals = JSON.parse(localStorage.getItem('nft-universe-signals') || '[]');
      const newSignals = [];
      
      signals.forEach(signal => {
        if (signal.roomId === this.roomId && signal.playerId !== this.playerId) {
          this.handleSignalingMessage(signal);
        } else {
          newSignals.push(signal);
        }
      });
      
      localStorage.setItem('nft-universe-signals', JSON.stringify(newSignals));
    }, 1000);
  }

  broadcastSignal(message) {
    message.roomId = this.roomId;
    message.playerId = this.playerId;
    message.timestamp = Date.now();
    
    if (this.signalingChannel) {
      this.signalingChannel.postMessage(message);
    } else {
      // Fallback to localStorage
      const signals = JSON.parse(localStorage.getItem('nft-universe-signals') || '[]');
      signals.push(message);
      localStorage.setItem('nft-universe-signals', JSON.stringify(signals));
    }
  }

  async handlePlayerJoin(message) {
    console.log('Player joined:', message.playerId);
    
    // Create peer connection for new player
    await this.createPeerConnection(message.playerId);
  }

  async createPeerConnection(peerId) {
    const configuration = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    };

    const peerConnection = new RTCPeerConnection(configuration);
    const dataChannel = peerConnection.createDataChannel('nft-universe', {
      ordered: true
    });

    this.setupDataChannel(dataChannel, peerId);

    peerConnection.onicecandidate = (event) => {
      if (event.candidate) {
        this.broadcastSignal({
          type: 'ice-candidate',
          to: peerId,
          candidate: event.candidate
        });
      }
    };

    peerConnection.ondatachannel = (event) => {
      this.setupDataChannel(event.channel, peerId);
    };

    // Create and send offer
    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);

    this.broadcastSignal({
      type: 'offer',
      to: peerId,
      offer: offer
    });

    this.peers.set(peerId, peerConnection);
    this.dataChannels.set(peerId, dataChannel);
  }

  async handleOffer(message) {
    const configuration = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    };

    const peerConnection = new RTCPeerConnection(configuration);

    peerConnection.onicecandidate = (event) => {
      if (event.candidate) {
        this.broadcastSignal({
          type: 'ice-candidate',
          to: message.playerId,
          candidate: event.candidate
        });
      }
    };

    peerConnection.ondatachannel = (event) => {
      this.setupDataChannel(event.channel, message.playerId);
    };

    await peerConnection.setRemoteDescription(message.offer);
    const answer = await peerConnection.createAnswer();
    await peerConnection.setLocalDescription(answer);

    this.broadcastSignal({
      type: 'answer',
      to: message.playerId,
      answer: answer
    });

    this.peers.set(message.playerId, peerConnection);
  }

  async handleAnswer(message) {
    const peerConnection = this.peers.get(message.playerId);
    if (peerConnection) {
      await peerConnection.setRemoteDescription(message.answer);
    }
  }

  async handleIceCandidate(message) {
    const peerConnection = this.peers.get(message.playerId);
    if (peerConnection && message.candidate) {
      await peerConnection.addIceCandidate(message.candidate);
    }
  }

  setupDataChannel(dataChannel, peerId) {
    dataChannel.onopen = () => {
      console.log('Data channel connected to', peerId);
      
      // Send initial player data
      this.sendPlayerData(peerId);
    };

    dataChannel.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        this.handlePlayerData(data);
      } catch (error) {
        console.error('Error parsing message:', error);
      }
    };

    dataChannel.onclose = () => {
      console.log('Data channel closed with', peerId);
      this.handlePlayerLeft({ playerId: peerId });
    };

    this.dataChannels.set(peerId, dataChannel);
  }

  getPlayerData() {
    return {
      name: this.playerName,
      color: this.playerColor,
      avatar: window.selectedAvatar,
      position: window.playerAvatar ? {
        x: window.playerAvatar.position.x,
        y: window.playerAvatar.position.y,
        z: window.playerAvatar.position.z,
        rotation: window.playerAvatar.rotation.y
      } : { x: 0, y: 3, z: 0, rotation: 0 }
    };
  }

  sendPlayerData(toPeerId = null) {
    const playerData = {
      type: 'player-data',
      playerId: this.playerId,
      data: this.getPlayerData()
    };

    if (toPeerId) {
      const dataChannel = this.dataChannels.get(toPeerId);
      if (dataChannel && dataChannel.readyState === 'open') {
        dataChannel.send(JSON.stringify(playerData));
      }
    } else {
      // Broadcast to all peers
      this.dataChannels.forEach((dataChannel, peerId) => {
        if (dataChannel.readyState === 'open') {
          dataChannel.send(JSON.stringify(playerData));
        }
      });
    }
  }

  handlePlayerData(message) {
    if (message.type === 'player-data') {
      this.createOrUpdateOtherPlayer(message.playerId, message.data);
    } else if (message.type === 'chat-message') {
      this.addChatMessage(message.sender, message.text, false);
    }
  }

  handlePlayerLeft(message) {
    this.removeOtherPlayer(message.playerId);
  }

  createOrUpdateOtherPlayer(playerId, playerData) {
    if (this.otherPlayers.has(playerId)) {
      // Update existing player
      this.updateOtherPlayerPosition(playerId, playerData.position);
    } else {
      // Create new player
      this.createOtherPlayer(playerId, playerData);
    }
  }

  createOtherPlayer(playerId, playerData) {
    if (window.scene && playerData.position) {
      const playerGroup = new THREE.Group();
      
      // Create floating board
      const boardGeometry = new THREE.PlaneGeometry(10, 10);
      const boardMaterial = new THREE.MeshStandardMaterial({ 
        color: playerData.color || 0x3B82F6,
        metalness: 0.8,
        roughness: 0.2,
        side: THREE.DoubleSide
      });
      const board = new THREE.Mesh(boardGeometry, boardMaterial);
      board.rotation.x = -Math.PI / 2;
      board.castShadow = true;
      board.receiveShadow = true;
      playerGroup.add(board);

      // Create avatar
      let avatar;
      if (playerData.avatar === 'boy') {
        const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 8);
        const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x3B82F6 });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.y = 1.5;
        
        const headGeometry = new THREE.SphereGeometry(0.6, 8, 8);
        const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFCD34D });
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.y = 2.8;
        
        avatar = new THREE.Group();
        avatar.add(body);
        avatar.add(head);
      } else {
        const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 8);
        const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xEC4899 });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.y = 1.5;
        
        const headGeometry = new THREE.SphereGeometry(0.6, 8, 8);
        const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFCD34D });
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.y = 2.8;
        
        avatar = new THREE.Group();
        avatar.add(body);
        avatar.add(head);
      }

      avatar.position.y = 0.1;
      avatar.castShadow = true;
      playerGroup.add(avatar);

      // Position the player
      playerGroup.position.set(
        playerData.position.x,
        playerData.position.y,
        playerData.position.z
      );
      playerGroup.rotation.y = playerData.position.rotation;
      playerGroup.castShadow = true;
      
      window.scene.add(playerGroup);

      // Create name tag
      const nameTag = this.createNameTag(playerData.name, playerData.color);
      playerGroup.add(nameTag);

      this.otherPlayers.set(playerId, {
        group: playerGroup,
        name: playerData.name,
        color: playerData.color,
        avatar: playerData.avatar
      });

      this.updatePlayersPanel();
      
      console.log('Created other player:', playerId, playerData.name);
    }
  }

  createNameTag(name, color) {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.width = 256;
    canvas.height = 64;
    
    // Draw background
    context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw text
    context.font = '24px Arial';
    context.fillStyle = '#FFFFFF';
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText(name, canvas.width / 2, canvas.height / 2);
    
    // Create texture from canvas
    const texture = new THREE.CanvasTexture(canvas);
    const material = new THREE.SpriteMaterial({ map: texture });
    const sprite = new THREE.Sprite(material);
    
    // Position above the player
    sprite.position.y = 5;
    sprite.scale.set(10, 2.5, 1);
    
    return sprite;
  }

  updateOtherPlayerPosition(playerId, position) {
    const otherPlayer = this.otherPlayers.get(playerId);
    if (otherPlayer && otherPlayer.group) {
      otherPlayer.group.position.set(position.x, position.y, position.z);
      otherPlayer.group.rotation.y = position.rotation;
    }
  }

  removeOtherPlayer(playerId) {
    const otherPlayer = this.otherPlayers.get(playerId);
    if (otherPlayer && otherPlayer.group && window.scene) {
      window.scene.remove(otherPlayer.group);
      this.otherPlayers.delete(playerId);
      this.updatePlayersPanel();
    }
  }

  updatePlayersPanel() {
    const playersList = document.getElementById('players-list');
    const playerCount = document.getElementById('player-count');
    
    if (playersList && playerCount) {
      playersList.innerHTML = '';
      playerCount.textContent = this.otherPlayers.size + 1;
      
      // Add current player
      const currentPlayerItem = document.createElement('div');
      currentPlayerItem.className = 'player-item';
      currentPlayerItem.innerHTML = `
        <div class="player-color" style="background-color: #${this.playerColor.toString(16).padStart(6, '0')};"></div>
        <div class="player-name">${this.playerName} (You)</div>
      `;
      playersList.appendChild(currentPlayerItem);
      
      // Add other players
      this.otherPlayers.forEach((player, playerId) => {
        const playerItem = document.createElement('div');
        playerItem.className = 'player-item';
        playerItem.innerHTML = `
          <div class="player-color" style="background-color: #${player.color.toString(16).padStart(6, '0')};"></div>
          <div class="player-name">${player.name}</div>
        `;
        playersList.appendChild(playerItem);
      });
    }
  }

  sendPositionUpdate() {
    if (window.playerAvatar) {
      this.sendPlayerData();
    }
  }

  setupChat() {
    const chatInput = document.getElementById('chat-input');
    const chatSend = document.getElementById('chat-send');
    
    if (chatSend) {
      chatSend.addEventListener('click', () => this.sendChatMessage());
    }
    
    if (chatInput) {
      chatInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          this.sendChatMessage();
        }
      });

      // Toggle chat with T key (desktop only)
      if (!window.isMobile) {
        document.addEventListener('keydown', (e) => {
          if (e.key === 't' || e.key === 'T') {
            chatInput.focus();
          }
        });
      }
    }
  }

  sendChatMessage() {
    const chatInput = document.getElementById('chat-input');
    const message = chatInput.value.trim();
    
    if (message) {
      const chatData = {
        type: 'chat-message',
        sender: this.playerName,
        text: message
      };
      
      // Send to all peers
      this.dataChannels.forEach((dataChannel, peerId) => {
        if (dataChannel.readyState === 'open') {
          dataChannel.send(JSON.stringify(chatData));
        }
      });
      
      // Add to local chat
      this.addChatMessage(this.playerName, message, true);
      chatInput.value = '';
    }
  }

  addChatMessage(sender, message, isOwn) {
    const chatMessages = document.getElementById('chat-messages');
    if (chatMessages) {
      const messageElement = document.createElement('div');
      messageElement.className = 'chat-message';
      
      if (isOwn) {
        messageElement.innerHTML = `<span class="chat-sender">You:</span> ${message}`;
      } else {
        messageElement.innerHTML = `<span class="chat-sender">${sender}:</span> ${message}`;
      }
      
      chatMessages.appendChild(messageElement);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }
  }

  // Clean up when leaving
  disconnect() {
    this.broadcastSignal({
      type: 'player-left',
      playerId: this.playerId
    });
    
    this.peers.forEach((peerConnection, peerId) => {
      peerConnection.close();
    });
    
    this.otherPlayers.forEach((player, playerId) => {
      this.removeOtherPlayer(playerId);
    });
    
    if (this.signalingChannel) {
      this.signalingChannel.close();
    }
  }
}

// Global multiplayer instance
let multiplayer;

/* ==============================
   AVATAR SELECTION
============================== */
let selectedAvatar = null;
const avatarOptions = document.querySelectorAll('.avatar-option');
const confirmButton = document.getElementById('confirm-avatar');
const avatarSelection = document.getElementById('avatar-selection');

avatarOptions.forEach(option => {
  option.addEventListener('click', () => {
    // Remove selected class from all options
    avatarOptions.forEach(opt => opt.classList.remove('selected'));
    // Add selected class to clicked option
    option.classList.add('selected');
    selectedAvatar = option.getAttribute('data-avatar');
  });
});

confirmButton.addEventListener('click', () => {
  if (selectedAvatar) {
    // Initialize multiplayer
    multiplayer = new WebRTCMultiplayer();
    
    // Set player name from input
    const nameInput = document.getElementById('player-name');
    if (nameInput && nameInput.value.trim()) {
      multiplayer.playerName = nameInput.value.trim();
    }
    
    // Generate random color for player
    multiplayer.playerColor = Math.random() * 0xFFFFFF;
    
    avatarSelection.style.display = 'none';
    init3DScene();
    loadNFTs();
    
    // Start position updates
    setInterval(() => {
      if (multiplayer) {
        multiplayer.sendPositionUpdate();
      }
    }, 100);
    
  } else {
    alert('Please select an avatar to continue');
  }
});

// ... (THE REST OF YOUR EXISTING CODE REMAINS EXACTLY THE SAME)
// All the existing functions like init3DScene, createWorld, createPlayerAvatar, etc.
// remain unchanged from your provided code

/* ==============================
   MOBILE DETECTION & CONTROLS
============================== */
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
let lookTouchId = null;
let lookStartX = 0, lookStartY = 0;
let lookX = 0, lookY = 0;
let velocity = new THREE.Vector3();
let canJump = true;

if (isMobile) {
  document.getElementById('desktop-instructions').style.display = 'none';
  document.getElementById('mobile-instructions').style.display = 'block';
  
  // Set up mobile movement controls
  document.getElementById('forward-btn').addEventListener('touchstart', (e) => {
    e.preventDefault();
    moveForward = true;
  });
  document.getElementById('forward-btn').addEventListener('touchend', (e) => {
    e.preventDefault();
    moveForward = false;
  });
  
  document.getElementById('backward-btn').addEventListener('touchstart', (e) => {
    e.preventDefault();
    moveBackward = true;
  });
  document.getElementById('backward-btn').addEventListener('touchend', (e) => {
    e.preventDefault();
    moveBackward = false;
  });
  
  document.getElementById('left-btn').addEventListener('touchstart', (e) => {
    e.preventDefault();
    moveLeft = true;
  });
  document.getElementById('left-btn').addEventListener('touchend', (e) => {
    e.preventDefault();
    moveLeft = false;
  });
  
  document.getElementById('right-btn').addEventListener('touchstart', (e) => {
    e.preventDefault();
    moveRight = true;
  });
  document.getElementById('right-btn').addEventListener('touchend', (e) => {
    e.preventDefault();
    moveRight = false;
  });
  
  document.getElementById('jump-btn').addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (canJump) {
      velocity.y += 350;
      canJump = false;
    }
  });
  
  // Set up look controls
  const lookControls = document.getElementById('look-controls');
  lookControls.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (lookTouchId === null) {
      const touch = e.touches[0];
      lookTouchId = touch.identifier;
      lookStartX = touch.clientX;
      lookStartY = touch.clientY;
    }
  });
  
  lookControls.addEventListener('touchmove', (e) => {
    e.preventDefault();
    for (let i = 0; i < e.changedTouches.length; i++) {
      const touch = e.changedTouches[i];
      if (touch.identifier === lookTouchId) {
        const deltaX = touch.clientX - lookStartX;
        const deltaY = touch.clientY - lookStartY;
        
        lookX = deltaX * 0.5;
        lookY = deltaY * 0.5;
        
        lookStartX = touch.clientX;
        lookStartY = touch.clientY;
        break;
      }
    }
  });
  
  lookControls.addEventListener('touchend', (e) => {
    e.preventDefault();
    for (let i = 0; i < e.changedTouches.length; i++) {
      const touch = e.changedTouches[i];
      if (touch.identifier === lookTouchId) {
        lookTouchId = null;
        lookX = 0;
        lookY = 0;
        break;
      }
    }
  });
}

/* ==============================
   3D SCENE SETUP - THIRD PERSON
============================== */
let scene, camera, renderer, controls;
let nftObjects = [], environmentObjects = [], buildingObjects = [];
let raycaster, mouse;
let currentIntersected = null;
let miniMapScene, miniMapCamera, miniMapRenderer;
let playerAvatar;
let worldSize = 800;
let worldBoundary = worldSize / 2 - 50;
let clock = new THREE.Clock();
let prevTime = 0;

// Third-person camera variables
let cameraDistance = 25;
let cameraHeight = 10;
let cameraAngle = 0;
let targetCameraAngle = 0;

// Floating board variables
let hoverBoard;
let hoverHeight = 3; // Height above ground
let hoverBobSpeed = 2; // Bobbing speed
let hoverBobAmount = 0.3; // Bobbing amount
let hoverTime = 0;

// Collision detection variables
let collisionObjects = [];
let roofObjects = [];
let playerCollider = new THREE.Box3();
let playerSize = new THREE.Vector3(10, 2, 10); // Same size as NFT displays
let playerOnRoof = false;
let currentRoof = null;

// NFT platform variables
let nftPlatforms = [];
let bridgeSegments = [];

function init3DScene() {
  // Create scene
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000033);
  scene.fog = new THREE.Fog(0x000033, 100, 2000);
  
  // Create camera - Third person perspective
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
  
  // Create renderer
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.getElementById('canvas-container').appendChild(renderer.domElement);
  
  // Add lighting
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
  scene.add(ambientLight);
  
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  directionalLight.position.set(100, 200, 100);
  directionalLight.castShadow = true;
  directionalLight.shadow.mapSize.width = 2048;
  directionalLight.shadow.mapSize.height = 2048;
  directionalLight.shadow.camera.near = 0.5;
  directionalLight.shadow.camera.far = 2000;
  directionalLight.shadow.camera.left = -500;
  directionalLight.shadow.camera.right = 500;
  directionalLight.shadow.camera.top = 500;
  directionalLight.shadow.camera.bottom = -500;
  scene.add(directionalLight);
  
  // Create the world
  createWorld();
  
  // Create player avatar with floating board
  createPlayerAvatar();
  
  // Set initial camera position for third-person view
  updateThirdPersonCamera();
  
  // Set up controls
  if (!isMobile) {
    controls = new THREE.PointerLockControls(camera, document.body);
    
    document.addEventListener('click', function() {
      if (!controls.isLocked) {
        controls.lock();
      }
    });
    
    controls.addEventListener('lock', function() {
      document.getElementById('instructions').style.display = 'none';
    });
    
    controls.addEventListener('unlock', function() {
      document.getElementById('instructions').style.display = 'block';
    });
    
    // Keyboard controls for desktop
    const onKeyDown = function (event) {
      switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
          moveForward = true;
          break;
        case 'ArrowLeft':
        case 'KeyA':
          moveLeft = true;
          break;
        case 'ArrowDown':
        case 'KeyS':
          moveBackward = true;
          break;
        case 'ArrowRight':
        case 'KeyD':
          moveRight = true;
          break;
        case 'Space':
          if (canJump) {
            velocity.y += 350;
            canJump = false;
          }
          break;
      }
    };
    
    const onKeyUp = function (event) {
      switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
          moveForward = false;
          break;
        case 'ArrowLeft':
        case 'KeyA':
          moveLeft = false;
          break;
        case 'ArrowDown':
        case 'KeyS':
          moveBackward = false;
          break;
        case 'ArrowRight':
        case 'KeyD':
          moveRight = false;
          break;
      }
    };
    
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);
    
    // Mouse movement for third-person camera
    document.addEventListener('mousemove', (event) => {
      if (controls && controls.isLocked) {
        targetCameraAngle -= event.movementX * 0.002;
      }
    });
  }
  
  // Set up raycaster for object interaction
  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2();
  
  // Handle window resize
  window.addEventListener('resize', onWindowResize);
  
  // Initialize mini-map
  initMiniMap();
  
  // Start animation
  animate();
}

function updateThirdPersonCamera() {
  if (!playerAvatar) return;
  
  // Smoothly interpolate camera angle
  cameraAngle += (targetCameraAngle - cameraAngle) * 0.1;
  
  // Calculate camera position behind and above the player
  const playerPosition = playerAvatar.position.clone();
  const offset = new THREE.Vector3(
    Math.sin(cameraAngle) * cameraDistance,
    cameraHeight,
    Math.cos(cameraAngle) * cameraDistance
  );
  
  camera.position.copy(playerPosition).add(offset);
  
  // Look at a point slightly above the player's position
  const lookAtPosition = playerPosition.clone();
  lookAtPosition.y += 3; // Look at center of avatar
  camera.lookAt(lookAtPosition);
}

function createWorld() {
  // Create massive ground plane
  const groundGeometry = new THREE.PlaneGeometry(worldSize, worldSize, 100, 100);
  const groundMaterial = new THREE.MeshLambertMaterial({ 
    color: 0x4ADE80,
    side: THREE.DoubleSide
  });
  const ground = new THREE.Mesh(groundGeometry, groundMaterial);
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);
  
  // Create city with buildings
  createCity();
  
  // Create spiral bridge
  createMoonBridge();
  
  // Add boundary walls to prevent going off map
  createBoundaryWalls();
}

function createMoonBridge() {
  const bridgeGroup = new THREE.Group();
  
  // Cyan bridge material
  const bridgeMaterial = new THREE.MeshLambertMaterial({ 
    color: 0x00FFFF,
    transparent: true,
    opacity: 0.7
  });
  
  const bridgeWidth = 20;
  const bridgeHeight = 5;
  const segments = 200;
  
  // Clear previous bridge segments
  bridgeSegments = [];
  
  // Create spiral bridge starting from edge with 30-degree incline
  for (let i = 0; i < segments; i++) {
    const t = i / segments;
    const nextT = (i + 1) / segments;
    
    // Spiral parametric equations starting from edge
    const spiralTurns = 4; // More turns for gradual 30-degree incline
    const startRadius = 350; // Start at edge of map
    const endRadius = 50; // End with smaller radius
    const totalHeight = 750;
    
    // Calculate radius - start large and get smaller
    const radius = startRadius - (t * (startRadius - endRadius));
    
    // Spiral coordinates
    const angle = t * Math.PI * 2 * spiralTurns;
    
    // Bridge starts at ground level (y=0) and goes up to pool level
    const x1 = Math.cos(angle) * radius;
    const z1 = Math.sin(angle) * radius;
    const y1 = 0 + t * totalHeight;
    
    const nextAngle = nextT * Math.PI * 2 * spiralTurns;
    const nextRadius = startRadius - (nextT * (startRadius - endRadius));
    
    const x2 = Math.cos(nextAngle) * nextRadius;
    const z2 = Math.sin(nextAngle) * nextRadius;
    const y2 = 0 + nextT * totalHeight;
    
    // Calculate segment length and direction
    const dx = x2 - x1;
    const dy = y2 - y1;
    const dz = z2 - z1;
    const segmentLength = Math.sqrt(dx*dx + dy*dy + dz*dz);
    
    // Create bridge segment
    const segmentGeometry = new THREE.BoxGeometry(bridgeWidth, bridgeHeight, segmentLength);
    const segment = new THREE.Mesh(segmentGeometry, bridgeMaterial);
    
    // Position segment at midpoint
    segment.position.set(
      (x1 + x2) / 2,
      (y1 + y2) / 2,
      (z1 + z2) / 2
    );
    
    // Rotate segment to follow the spiral
    segment.rotation.y = Math.atan2(dx, dz);
    segment.rotation.x = -Math.atan2(dy, Math.sqrt(dx*dx + dz*dz));
    
    segment.castShadow = true;
    segment.receiveShadow = true;
    bridgeGroup.add(segment);
    
    // Store segment for collision detection
    bridgeSegments.push(segment);
    
    // Create guardrails
    createBridgeGuardrails(bridgeGroup, x1, y1, z1, x2, y2, z2, segmentLength);
  }
  
  scene.add(bridgeGroup);
}

function createBridgeGuardrails(bridgeGroup, x1, y1, z1, x2, y2, z2, segmentLength) {
  const railGeometry = new THREE.BoxGeometry(1, 10, segmentLength);
  const railMaterial = new THREE.MeshLambertMaterial({ color: 0x4B5563 });
  
  // Calculate direction vector
  const dx = x2 - x1;
  const dy = y2 - y1;
  const dz = z2 - z1;
  
  // Calculate perpendicular vector for rail offset
  const length = Math.sqrt(dx*dx + dz*dz);
  const perpX = -dz / length * 10.5;
  const perpZ = dx / length * 10.5;
  
  // Left rail
  const leftRail = new THREE.Mesh(railGeometry, railMaterial);
  leftRail.position.set(
    (x1 + x2) / 2 + perpX,
    (y1 + y2) / 2 + 5,
    (z1 + z2) / 2 + perpZ
  );
  leftRail.rotation.y = Math.atan2(dx, dz);
  leftRail.rotation.x = -Math.atan2(dy, Math.sqrt(dx*dx + dz*dz));
  leftRail.castShadow = true;
  bridgeGroup.add(leftRail);
  
  // Right rail
  const rightRail = new THREE.Mesh(railGeometry, railMaterial);
  rightRail.position.set(
    (x1 + x2) / 2 - perpX,
    (y1 + y2) / 2 + 5,
    (z1 + z2) / 2 - perpZ
  );
  rightRail.rotation.y = Math.atan2(dx, dz);
  rightRail.rotation.x = -Math.atan2(dy, Math.sqrt(dx*dx + dz*dz));
  rightRail.castShadow = true;
  bridgeGroup.add(rightRail);
  
  // Add rails to collision objects
  const leftRailBox = new THREE.Box3().setFromObject(leftRail);
  const rightRailBox = new THREE.Box3().setFromObject(rightRail);
  collisionObjects.push(leftRailBox);
  collisionObjects.push(rightRailBox);
}

function createBoundaryWalls() {
  const wallHeight = 100;
  const wallMaterial = new THREE.MeshLambertMaterial({ 
    color: 0x374151,
    transparent: true,
    opacity: 0.7
  });
  
  // Create walls around the perimeter
  const wallGeometry = new THREE.PlaneGeometry(worldSize, wallHeight);
  
  // North wall
  const northWall = new THREE.Mesh(wallGeometry, wallMaterial);
  northWall.position.set(0, wallHeight/2, -worldBoundary);
  northWall.rotation.x = Math.PI / 2;
  scene.add(northWall);
  
  // South wall
  const southWall = new THREE.Mesh(wallGeometry, wallMaterial);
  southWall.position.set(0, wallHeight/2, worldBoundary);
  southWall.rotation.x = -Math.PI / 2;
  scene.add(southWall);
  
  // East wall
  const eastWall = new THREE.Mesh(wallGeometry, wallMaterial);
  eastWall.position.set(worldBoundary, wallHeight/2, 0);
  eastWall.rotation.x = Math.PI / 2;
  eastWall.rotation.y = Math.PI / 2;
  scene.add(eastWall);
  
  // West wall
  const westWall = new THREE.Mesh(wallGeometry, wallMaterial);
  westWall.position.set(-worldBoundary, wallHeight/2, 0);
  westWall.rotation.x = Math.PI / 2;
  westWall.rotation.y = -Math.PI / 2;
  scene.add(westWall);
}

function createCity() {
  const cityGroup = new THREE.Group();
  const buildingColors = [0x3B82F6, 0xEF4444, 0x10B981, 0xF59E0B, 0x8B5CF6];
  
  // Create buildings with WIDER dimensions
  const gridSize = 5;
  const spacing = 120; // Increased spacing for wider buildings
  
  for (let x = 0; x < gridSize; x++) {
    for (let z = 0; z < gridSize; z++) {
      // Make buildings WIDER but not as tall
      const width = 40 + Math.random() * 30;  // Increased from 20-35 to 40-70
      const depth = 40 + Math.random() * 30;  // Increased from 20-35 to 40-70
      const height = 20 + Math.random() * 40; // Reduced height for better proportions
      
      const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
      const buildingMaterial = new THREE.MeshLambertMaterial({ 
        color: buildingColors[Math.floor(Math.random() * buildingColors.length)] 
      });
      
      const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
      
      // Position buildings with more spacing
      building.position.set(
        (x - gridSize/2) * spacing,
        height / 2,
        (z - gridSize/2) * spacing - 100
      );
      
      building.castShadow = true;
      building.receiveShadow = true;
      cityGroup.add(building);
      buildingObjects.push(building);
      
      // Add building to collision objects
      const buildingBox = new THREE.Box3().setFromObject(building);
      collisionObjects.push(buildingBox);
      
      // Create a solid roof plane for walking on top of the building
      createBuildingRoof(building.position.x, building.position.y + height/2, building.position.z, width, depth);
    }
  }
  
  scene.add(cityGroup);
}

function createBuildingRoof(x, y, z, width, depth) {
  // Create a solid roof plane for collision
  const roofGeometry = new THREE.PlaneGeometry(width, depth);
  const roofMaterial = new THREE.MeshLambertMaterial({ 
    color: 0x1F2937,
    side: THREE.DoubleSide
  });
  
  const roof = new THREE.Mesh(roofGeometry, roofMaterial);
  roof.position.set(x, y + 0.1, z);
  roof.rotation.x = Math.PI / 2;
  
  // Make the roof solid and visible
  roof.receiveShadow = true;
  roof.castShadow = true;
  
  scene.add(roof);
  
  // Add roof to collision objects for walking on
  const roofBox = new THREE.Box3().setFromCenterAndSize(
    new THREE.Vector3(x, y + 0.1, z),
    new THREE.Vector3(width, 0.2, depth)
  );
  roofObjects.push({
    box: roofBox,
    position: new THREE.Vector3(x, y + 0.1, z),
    width: width,
    depth: depth
  });
  
  // Also add the roof to the main collision objects to prevent falling through
  collisionObjects.push(roofBox);
}

function createPlayerAvatar() {
  // Create a group for the entire player (avatar + hover board)
  const group = new THREE.Group();
  
  // Create a FLAT rectangular board (same dimensions as NFTs) - LAYING DOWN FLAT
  const boardGeometry = new THREE.PlaneGeometry(10, 10); // Same size as NFT displays
  const boardMaterial = new THREE.MeshStandardMaterial({ 
    color: multiplayer ? multiplayer.playerColor : 0xC0C0C0,
    metalness: 0.8,
    roughness: 0.2,
    side: THREE.DoubleSide
  });
  hoverBoard = new THREE.Mesh(boardGeometry, boardMaterial);
  // Lay the board flat (rotate to be horizontal)
  hoverBoard.rotation.x = -Math.PI / 2; // Rotate to lay flat on ground
  hoverBoard.castShadow = true;
  hoverBoard.receiveShadow = true;
  group.add(hoverBoard);
  
  // Add green underglow to the hover board
  const underglowGeometry = new THREE.PlaneGeometry(10.5, 10.5);
  const underglowMaterial = new THREE.MeshBasicMaterial({ 
    color: 0x00FF00, // Bright green
    transparent: true,
    opacity: 0.7,
    side: THREE.DoubleSide
  });
  const underglow = new THREE.Mesh(underglowGeometry, underglowMaterial);
  underglow.rotation.x = -Math.PI / 2; // Lay flat like the board
  underglow.position.y = -0.1; // Position slightly below the board
  group.add(underglow);
  
  // Create the avatar standing on the board
  let avatar;
  if (selectedAvatar === 'boy') {
    // Create boy avatar - blue color scheme
    const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 8);
    const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x3B82F6 });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    body.position.y = 1.5;
    
    const headGeometry = new THREE.SphereGeometry(0.6, 8, 8);
    const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFCD34D });
    const head = new THREE.Mesh(headGeometry, headMaterial);
    head.position.y = 2.8;
    
    avatar = new THREE.Group();
    avatar.add(body);
    avatar.add(head);
    
  } else if (selectedAvatar === 'girl') {
    // Create girl avatar - pink color scheme
    const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 8);
    const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xEC4899 });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    body.position.y = 1.5;
    
    const headGeometry = new THREE.SphereGeometry(0.6, 8, 8);
    const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFCD34D });
    const head = new THREE.Mesh(headGeometry, headMaterial);
    head.position.y = 2.8;
    
    avatar = new THREE.Group();
    avatar.add(body);
    avatar.add(head);
  }
  
  // Position avatar on top of the hover board
  if (avatar) {
    avatar.position.y = 0.1; // On top of the board
    avatar.castShadow = true;
    group.add(avatar);
  }
  
  // Position the entire group at the starting point
  group.position.set(0, hoverHeight, 0);
  group.castShadow = true;
  scene.add(group);
  
  playerAvatar = group;
}

function initMiniMap() {
  miniMapScene = new THREE.Scene();
  miniMapCamera = new THREE.OrthographicCamera(-worldSize/2, worldSize/2, worldSize/2, -worldSize/2, 0.1, 2000);
  miniMapCamera.position.y = 500;
  miniMapCamera.lookAt(0, 0, 0);
  
  const miniMapCanvas = document.createElement('canvas');
  miniMapCanvas.width = 120;
  miniMapCanvas.height = 120;
  document.getElementById('mini-map').appendChild(miniMapCanvas);
  
  miniMapRenderer = new THREE.WebGLRenderer({ 
    canvas: miniMapCanvas,
    antialias: false 
  });
  miniMapRenderer.setSize(120, 120);
  miniMapRenderer.setClearColor(0x000000, 0.5);
  
  // Add ground to mini-map
  const groundGeometry = new THREE.PlaneGeometry(worldSize, worldSize);
  const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x4ADE80 });
  const ground = new THREE.Mesh(groundGeometry, groundMaterial);
  ground.rotation.x = -Math.PI / 2;
  miniMapScene.add(ground);
  
  // Add player indicator
  const playerGeometry = new THREE.CircleGeometry(10, 8);
  const playerMaterial = new THREE.MeshBasicMaterial({ 
    color: multiplayer ? multiplayer.playerColor : 0xFF0000 
  });
  const playerIndicator = new THREE.Mesh(playerGeometry, playerMaterial);
  playerIndicator.rotation.x = -Math.PI / 2;
  miniMapScene.add(playerIndicator);
  
  // Add other player indicators
  const otherPlayerGeometry = new THREE.CircleGeometry(8, 6);
  const otherPlayerMaterial = new THREE.MeshBasicMaterial({ color: 0xFF6B6B });
  
  window.updateMiniMap = function() {
    // Update player position
    playerIndicator.position.x = playerAvatar.position.x;
    playerIndicator.position.z = playerAvatar.position.z;
    
    // Update player avatar rotation based on camera angle
    if (playerAvatar) {
      playerAvatar.rotation.y = cameraAngle + Math.PI;
    }
    
    // Update location info
    updateLocationInfo();
    
    // Clear previous NFT indicators
    miniMapScene.children.forEach((child, index) => {
      if (child.userData && child.userData.isNFTIndicator) {
        miniMapScene.children.splice(index, 1);
      }
    });
    
    // Add current NFT indicators
    nftObjects.forEach(nft => {
      const indicator = new THREE.Mesh(otherPlayerGeometry, otherPlayerMaterial);
      indicator.position.x = nft.position.x;
      indicator.position.z = nft.position.z;
      indicator.rotation.x = -Math.PI / 2;
      indicator.userData = { isNFTIndicator: true };
      miniMapScene.add(indicator);
    });
    
    miniMapRenderer.render(miniMapScene, miniMapCamera);
  };
}

function updateLocationInfo() {
  const locationInfo = document.getElementById('location-info');
  const x = playerAvatar.position.x;
  const z = playerAvatar.position.z;
  const y = playerAvatar.position.y;
  
  // Check if player is on bridge
  const isOnBridge = checkIfOnBridge(playerAvatar.position);
  
  if (isOnBridge) {
    locationInfo.textContent = "Location: Spiral Bridge (Floating)";
  }
  // Check if player is in the city
  else if (x > -200 && x < 200 && z > -200 && z < 200) {
    locationInfo.textContent = "Location: City Center (Floating)";
  }
  // Check if player is in the NFT column
  else if (y > 100) {
    locationInfo.textContent = "Location: NFT Column (Floating)";
  }
  // Otherwise in the grass fields
  else {
    locationInfo.textContent = "Location: Grass Fields (Floating)";
  }
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

// Check if player is on bridge
function checkIfOnBridge(position) {
  // Check if player is close to any bridge segment
  for (let i = 0; i < bridgeSegments.length; i++) {
    const segment = bridgeSegments[i];
    const distance = position.distanceTo(segment.position);
    
    // If player is within reasonable distance of bridge segment and at similar height
    if (distance < 30 && Math.abs(position.y - segment.position.y) < 15) {
      return true;
    }
  }
  return false;
}

// COLLISION DETECTION FOR FLOATING BOARD
function checkCollisions(newPosition) {
  // Update player collider position and size for floating board
  playerCollider.setFromCenterAndSize(
    new THREE.Vector3(newPosition.x, newPosition.y, newPosition.z),
    playerSize
  );
  
  // Check if player is on bridge and allow movement
  const isOnBridge = checkIfOnBridge(newPosition);
  
  if (isOnBridge) {
    return false; // No collision when on bridge
  }
  
  // Check for collisions with all collision objects
  for (let i = 0; i < collisionObjects.length; i++) {
    if (playerCollider.intersectsBox(collisionObjects[i])) {
      return true; // Collision detected
    }
  }
  
  return false; // No collision
}

function animate() {
  requestAnimationFrame(animate);
  
  const time = performance.now();
  const delta = (time - prevTime) / 1000;
  hoverTime += delta;
  
  // Handle movement
  if ((controls && controls.isLocked) || isMobile) {
    const moveSpeed = 200.0 * delta;
    
    // Store current position for collision detection
    const currentPosition = playerAvatar.position.clone();
    
    // Calculate new position based on movement
    const newPosition = currentPosition.clone();
    
    // Calculate movement direction based on camera angle
    const forward = new THREE.Vector3(
      Math.sin(cameraAngle),
      0,
      Math.cos(cameraAngle)
    );
    const right = new THREE.Vector3(
      Math.sin(cameraAngle + Math.PI/2),
      0,
      Math.cos(cameraAngle + Math.PI/2)
    );
    
    if (moveForward) {
      newPosition.add(forward.clone().multiplyScalar(moveSpeed));
    }
    if (moveBackward) {
      newPosition.sub(forward.clone().multiplyScalar(moveSpeed));
    }
    if (moveLeft) {
      newPosition.sub(right.clone().multiplyScalar(moveSpeed));
    }
    if (moveRight) {
      newPosition.add(right.clone().multiplyScalar(moveSpeed));
    }
    
    // Check if player is on bridge
    const isOnBridge = checkIfOnBridge(newPosition);
    
    if (isOnBridge) {
      // On bridge - follow bridge height with floating effect
      let bridgeHeight = 0;
      for (let i = 0; i < bridgeSegments.length; i++) {
        const segment = bridgeSegments[i];
        const distance = newPosition.distanceTo(segment.position);
        if (distance < 30) {
          bridgeHeight = segment.position.y;
          break;
        }
      }
      newPosition.y = bridgeHeight + hoverHeight + (Math.sin(hoverTime * hoverBobSpeed) * hoverBobAmount);
    } else {
      // Not on bridge - normal floating
      const hoverBob = Math.sin(hoverTime * hoverBobSpeed) * hoverBobAmount;
      newPosition.y = hoverHeight + hoverBob;
    }
    
    // Apply jump physics if jumping
    if (velocity.y !== 0) {
      velocity.y -= 9.8 * 100.0 * delta;
      newPosition.y += (velocity.y * delta);
      
      // Reset jump when back to normal hover height
      if (newPosition.y <= hoverHeight + (Math.sin(hoverTime * hoverBobSpeed) * hoverBobAmount) && velocity.y < 0 && !isOnBridge) {
        velocity.y = 0;
        canJump = true;
      }
    }
    
    // Check for collisions before updating position
    if (!checkCollisions(newPosition)) {
      // No collision, update position
      playerAvatar.position.copy(newPosition);
    } else {
      // Collision detected, revert to original position
      playerAvatar.position.copy(currentPosition);
    }
    
    // Prevent going outside world boundaries
    if (playerAvatar.position.x > worldBoundary) {
      playerAvatar.position.x = worldBoundary;
    }
    if (playerAvatar.position.x < -worldBoundary) {
      playerAvatar.position.x = -worldBoundary;
    }
    if (playerAvatar.position.z > worldBoundary) {
      playerAvatar.position.z = worldBoundary;
    }
    if (playerAvatar.position.z < -worldBoundary) {
      playerAvatar.position.z = -worldBoundary;
    }
  }
  
  // Handle look for mobile
  if (isMobile && (lookX !== 0 || lookY !== 0)) {
    targetCameraAngle -= lookX * 0.01;
    // Limit vertical camera movement for third-person
    cameraHeight = Math.max(5, Math.min(20, cameraHeight - lookY * 0.1));
  }
  
  // Update third-person camera
  updateThirdPersonCamera();
  
  // Update raycaster for object interaction
  raycaster.set(camera.position, camera.getWorldDirection(new THREE.Vector3()));
  
  const intersects = raycaster.intersectObjects(nftObjects);
  
  if (intersects.length > 0) {
    if (currentIntersected !== intersects[0].object) {
      // Reset previous intersection
      if (currentIntersected) {
        currentIntersected.material.emissive.setHex(currentIntersected.userData.originalEmissive);
      }
      
      // Set new intersection
      currentIntersected = intersects[0].object;
      currentIntersected.userData.originalEmissive = currentIntersected.material.emissive.getHex();
      currentIntersected.material.emissive.setHex(0x3b82f6);
      
      // Change cursor to pointer
      if (!isMobile) {
        document.body.style.cursor = 'pointer';
      }
    }
  } else {
    if (currentIntersected) {
      currentIntersected.material.emissive.setHex(currentIntersected.userData.originalEmissive);
      currentIntersected = null;
      if (!isMobile) {
        document.body.style.cursor = 'auto';
      }
    }
  }
  
  // Update mini-map
  if (window.updateMiniMap) {
    window.updateMiniMap();
  }
  
  prevTime = time;
  renderer.render(scene, camera);
}

/* ==============================
   NFT PLATFORM CREATION
============================== */
function createNFTPlatform(x, y, z) {
  // Create a floating platform for the NFT
  const platformGeometry = new THREE.CylinderGeometry(6, 6, 0.5, 16);
  const platformMaterial = new THREE.MeshLambertMaterial({ 
    color: 0x2a2a5a,
    transparent: true,
    opacity: 0.8
  });
  
  const platform = new THREE.Mesh(platformGeometry, platformMaterial);
  platform.position.set(x, y - 4, z);
  platform.receiveShadow = true;
  scene.add(platform);
  
  // Add platform to collision objects
  const platformBox = new THREE.Box3().setFromObject(platform);
  collisionObjects.push(platformBox);
  nftPlatforms.push(platform);
  
  return platform;
}

function createNFTPlane(nftData, position) {
  // Create a plane for the NFT image (same size as player board)
  const geometry = new THREE.PlaneGeometry(10, 10);
  const textureLoader = new THREE.TextureLoader();
  
  const material = new THREE.MeshStandardMaterial({ 
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.9
  });
  
  const plane = new THREE.Mesh(geometry, material);
  plane.position.set(position.x, position.y, position.z);
  
  // Rotate to face a random direction
  plane.rotation.y = Math.random() * Math.PI * 2;
  
  // Store NFT data for interaction
  plane.userData = {
    nftData: nftData,
    isNFT: true,
    originalEmissive: 0x000000
  };
  
  // Load the NFT image
  textureLoader.load(nftData.image_url || 'https://via.placeholder.com/400x400?text=NFT+Image', function(texture) {
    material.map = texture;
    material.needsUpdate = true;
  }, undefined, function(err) {
    console.error('Error loading NFT image:', err);
  });
  
  plane.castShadow = true;
  plane.receiveShadow = true;
  scene.add(plane);
  nftObjects.push(plane);
  
  // Add a subtle glow effect
  const glowGeometry = new THREE.PlaneGeometry(10.5, 10.5);
  const glowMaterial = new THREE.MeshBasicMaterial({ 
    color: 0x3b82f6,
    transparent: true,
    opacity: 0.4,
    side: THREE.DoubleSide
  });
  const glow = new THREE.Mesh(glowGeometry, glowMaterial);
  glow.position.copy(plane.position);
  glow.rotation.copy(plane.rotation);
  scene.add(glow);
  
  // Make glow part of the NFT object for interaction
  plane.userData.glow = glow;
}

function openNFTModal(nftData) {
  document.getElementById('modal-image').src = nftData.image_url || 'https://via.placeholder.com/400x400?text=NFT+Image';
  document.getElementById('modal-title').textContent = nftData.name || `${nftData.collection || 'Untitled'} #${nftData.token_id || ''}`;
  document.getElementById('modal-description').textContent = nftData.description || 'No description available';
  document.getElementById('modal-price').textContent = nftData.price_eth || 'N/A';
  
  const actions = document.getElementById('modal-actions');
  actions.innerHTML = '';
  
  if (!account) {
    const connectBtn = document.createElement('button');
    connectBtn.textContent = 'Connect Wallet to Interact';
    connectBtn.onclick = connectWallet;
    actions.appendChild(connectBtn);
  } else {
    const buyBtn = document.createElement('button');
    buyBtn.textContent = 'Buy NFT';
    buyBtn.onclick = () => buyNFT(nftData);
    actions.appendChild(buyBtn);
    
    const transferBtn = document.createElement('button');
    transferBtn.textContent = 'Transfer NFT';
    transferBtn.onclick = () => transferNFT(nftData);
    actions.appendChild(transferBtn);
  }
  
  document.getElementById('nft-modal').style.display = 'block';
}

document.getElementById('close-modal').addEventListener('click', function() {
  document.getElementById('nft-modal').style.display = 'none';
});

// Handle click/tap on NFT
document.addEventListener('click', function onClick(event) {
  if (((!isMobile && controls && controls.isLocked) || (isMobile && currentIntersected)) && currentIntersected) {
    const nftData = currentIntersected.userData.nftData;
    openNFTModal(nftData);
  }
});

/* ==============================
   CONNECT WALLET (MetaMask + WalletConnect)
============================== */
async function connectWallet() {
  try {
    if (window.ethereum) {
      web3 = new Web3(window.ethereum);
      const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
      account = accounts[0];
    } else {
      const provider = new WalletConnectProvider.default({
        rpc: { 1: "https://mainnet.infura.io/v3/d71dd33696d449e488a88bdc02a6093c" },
      });
      await provider.enable();
      web3 = new Web3(provider);
      const accounts = await web3.eth.getAccounts();
      account = accounts[0];
    }

    document.getElementById("walletStatus").innerText =
      `‚úÖ Connected: ${account.slice(0, 6)}...${account.slice(-4)}`;

    nftContract = new web3.eth.Contract(NFT_ABI, NFT_CONTRACT_ADDRESS);
    
    // Reload NFTs to show wallet-specific options
    if (avatarSelection.style.display === 'none') {
      loadNFTs();
    }

  } catch (err) {
    console.error(err);
    alert("Failed to connect wallet.");
  }
}

document.getElementById("connectBtn").addEventListener("click", connectWallet);

/* ==============================
   LOAD NFTs FROM SUPABASE
============================== */
async function loadNFTs() {
  try {
    const { data, error } = await client.from("nfts").select("*").order("created_at", { ascending: false });

    if (error) {
      console.error("Error loading NFTs:", error);
      return;
    }
    
    if (!data || data.length === 0) {
      console.log("No NFTs found in database");
      return;
    }

    console.log(`Loaded ${data.length} NFTs from Supabase`);

    // Clear existing NFTs
    nftObjects.forEach(obj => {
      scene.remove(obj);
      if (obj.userData.glow) {
        scene.remove(obj.userData.glow);
      }
    });
    nftObjects = [];
    
    // Clear existing platforms
    nftPlatforms.forEach(platform => {
      scene.remove(platform);
    });
    nftPlatforms = [];
    
    // Create a random vertical column of NFTs
    createRandomNFTColumn(data);
    
    // Update NFT counter
    document.getElementById('nft-count').textContent = data.length;
    
  } catch (err) {
    console.error("Failed to load NFTs:", err);
  }
}

/* ==============================
   CREATE RANDOM VERTICAL NFT COLUMN
============================== */
function createRandomNFTColumn(nfts) {
  const columnHeight = 500; // Height of the vertical column
  const baseX = 0; // Center of the map
  const baseZ = 0; // Center of the map
  const maxRadius = 60; // Maximum distance from center
  
  // Create platforms and NFTs at random positions within the column
  nfts.forEach((nft, index) => {
    // Random position within a cylindrical volume
    const height = Math.random() * columnHeight;
    const radius = Math.random() * maxRadius; // Random distance from center
    const angle = Math.random() * Math.PI * 2; // Random angle
    
    const x = baseX + Math.cos(angle) * radius;
    const y = height + 10; // Start above ground
    const z = baseZ + Math.sin(angle) * radius;
    
    // Create floating platform for the NFT
    createNFTPlatform(x, y, z);
    
    // Create the NFT display
    createNFTPlane(nft, { x, y, z });
  });
}

/* ==============================
   BUY NFT
============================== */
async function buyNFT(nftData) {
  if (!account) return alert("Connect wallet first.");
  try {
    const priceEth = nftData.price_eth || 0.1;
    const totalEth = web3.utils.toWei((Number(priceEth) + 6/1000).toString(), 'ether');
    await web3.eth.sendTransaction({ from: account, to: RECEIVER_ADDRESS, value: totalEth });

    await client.from("nfts").update({ owner: account, sold: true }).eq("token_id", nftData.token_id);
    alert("‚úÖ NFT purchased! Payment sent.");
    loadNFTs();
    document.getElementById('nft-modal').style.display = 'none';
  } catch(err) { 
    console.error(err); 
    alert("Buy failed: " + err.message); 
  }
}

/* ==============================
   SELL NFT
============================== */
async function sellNFT(nftData) {
  if (!account) return alert("Connect wallet first.");
  const priceEth = prompt("Enter sale price in ETH:");
  if (!priceEth) return;
  await client.from("nfts").update({ sold: false, price_eth: priceEth, owner: account }).eq("token_id", nftData.token_id);
  alert("‚úÖ NFT listed for sale!");
  loadNFTs();
  document.getElementById('nft-modal').style.display = 'none';
}

/* ==============================
   TRANSFER NFT
============================== */
async function transferNFT(nftData) {
  if (!account) return alert("Connect wallet first.");
  const recipient = prompt("Enter recipient wallet address:");
  if (!recipient) return;
  try {
    const feeEth = web3.utils.toWei((6/1000).toString(), 'ether');
    await web3.eth.sendTransaction({ from: account, to: RECEIVER_ADDRESS, value: feeEth });

    await nftContract.methods.safeTransferFrom(account, recipient, nftData.token_id).send({ from: account });

    await client.from("nfts").update({ owner: recipient }).eq("token_id", nftData.token_id);
    alert("‚úÖ NFT transferred! Fee sent.");
    loadNFTs();
    document.getElementById('nft-modal').style.display = 'none';
  } catch(err) { 
    console.error(err); 
    alert("Transfer failed: " + err.message); 
  }
}

// Clean up multiplayer when page unloads
window.addEventListener('beforeunload', () => {
  if (multiplayer) {
    multiplayer.disconnect();
  }
});

// The 3D scene will be initialized after avatar selection
</script>

</body>
</html>
