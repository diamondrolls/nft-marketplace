<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>üíé 3D NFT Universe</title>

<!-- Supabase & Web3.js & WalletConnect -->
<script src="https://unpkg.com/@supabase/supabase-js"></script>
<script src="https://cdn.jsdelivr.net/npm/web3/dist/web3.min.js"></script>
<script src="https://unpkg.com/@walletconnect/web3-provider@1.8.0/dist/umd/index.min.js"></script>

<!-- Three.js for 3D rendering -->
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>

<style>
  :root {
    --bg: #f8fafc;
    --card-bg: #ffffff;
    --text-dark: #1e293b;
    --text-light: #475569;
    --accent: #3b82f6;
    --shadow: 0 4px 12px rgba(0,0,0,0.08);
  }
  
  .homepage{
    border-style: outset;
    width: 120px;
    height: 45px;
    background-image: url('https://i.pinimg.com/564x/35/38/ed/3538edbdb531c7fe3bb387ead4b398b0.jpg');
    background-size: 120px 45px;
    border-radius: 50%;
    text-align: center;
    line-height: 45px;
    color: white;
    font-weight: bold;
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 100;
    font-size: 0.8rem;
  }
  
  * { box-sizing: border-box; }
  body { 
    font-family: system-ui, sans-serif; 
    background: var(--bg); 
    margin: 0; 
    padding: 0; 
    color: var(--text-dark); 
    overflow: hidden;
    touch-action: none;
  }
  
  header { 
    background: var(--card-bg); 
    text-align: center; 
    padding: 12px 8px; 
    border-bottom: 1px solid #e2e8f0; 
    position: absolute; 
    top: 0; 
    width: 100%; 
    z-index: 10; 
  }
  
  h1 { font-size: 1.4rem; margin: 0; }
  #walletStatus { margin-top: 6px; font-size: 0.8rem; color: var(--text-light); }
  #connectBtn { 
    margin-top: 4px; 
    padding: 4px 8px;
    font-size: 0.8rem;
  }
  
  #canvas-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }
  
  #instructions {
    position: absolute;
    bottom: 10px;
    left: 0;
    width: 100%;
    text-align: center;
    color: white;
    background-color: rgba(0,0,0,0.7);
    padding: 8px;
    z-index: 100;
    font-size: 0.8rem;
  }
  
  #mobile-controls {
    position: absolute;
    bottom: 80px;
    right: 10px;
    z-index: 100;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  
  .mobile-btn {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: rgba(59, 130, 246, 0.7);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.2rem;
    font-weight: bold;
    user-select: none;
    -webkit-user-select: none;
  }
  
  #look-controls {
    position: absolute;
    bottom: 80px;
    left: 10px;
    width: 120px;
    height: 120px;
    z-index: 100;
    background: rgba(0,0,0,0.2);
    border-radius: 50%;
    touch-action: none;
  }
  
  #nft-modal {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--card-bg);
    border-radius: 16px;
    box-shadow: var(--shadow);
    padding: 20px;
    z-index: 1000;
    max-width: 90%;
    width: 350px;
    max-height: 80vh;
    overflow-y: auto;
  }
  
  #nft-modal img {
    width: 100%;
    height: 200px;
    object-fit: cover;
    display: block;
    border-radius: 8px;
    margin-bottom: 15px;
  }
  
  #nft-modal h3 {
    margin: 8px 0 4px;
    font-size: 1.1rem;
    font-weight: 600;
  }
  
  #nft-modal p {
    margin: 4px 0;
    font-size: 0.9rem;
    color: var(--text-light);
  }
  
  .nft-actions {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-top: 10px;
  }
  
  button {
    border: none;
    background: var(--accent);
    color: white;
    padding: 8px 12px;
    border-radius: 8px;
    font-size: 0.85rem;
    cursor: pointer;
    transition: background 0.2s;
  }
  
  button:hover {
    background: #2563eb;
  }
  
  #close-modal {
    position: absolute;
    top: 10px;
    right: 10px;
    background: #ef4444;
    width: 30px;
    height: 30px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  #close-modal:hover {
    background: #dc2626;
  }
  
  #mini-map {
    position: absolute;
    top: 70px;
    right: 10px;
    width: 120px;
    height: 120px;
    background: rgba(0,0,0,0.5);
    border-radius: 8px;
    z-index: 100;
    border: 2px solid white;
  }
  
  #location-info {
    position: absolute;
    top: 70px;
    left: 10px;
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 8px 12px;
    border-radius: 8px;
    font-size: 0.8rem;
    z-index: 100;
    max-width: 200px;
  }
  
  #avatar-selection {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.8);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 2000;
  }
  
  #avatar-selection h2 {
    color: white;
    margin-bottom: 30px;
    font-size: 1.8rem;
  }
  
  .avatar-options {
    display: flex;
    gap: 30px;
    flex-wrap: wrap;
    justify-content: center;
  }
  
  .avatar-option {
    width: 200px;
    height: 300px;
    border-radius: 12px;
    overflow: hidden;
    cursor: pointer;
    transition: transform 0.3s, box-shadow 0.3s;
    border: 3px solid transparent;
  }
  
  .avatar-option:hover {
    transform: scale(1.05);
    box-shadow: 0 10px 20px rgba(0,0,0,0.3);
  }
  
  .avatar-option.selected {
    border-color: var(--accent);
    box-shadow: 0 0 20px var(--accent);
  }
  
  #boy-avatar {
    background-image: url('https://raw.githubusercontent.com/diamondrolls/images/main/431BBB65-C6F8-49BC-B882-EA5BBE885462.png');
    background-size: cover;
    background-position: center;
  }
  
  #girl-avatar {
    background-image: url('https://raw.githubusercontent.com/diamondrolls/images/main/3974D02C-0D5B-4F49-8597-5185D48FB2A1.png');
    background-size: cover;
    background-position: center;
  }
  
  #confirm-avatar {
    margin-top: 30px;
    padding: 12px 24px;
    font-size: 1.1rem;
    background: var(--accent);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.2s;
  }
  
  #confirm-avatar:hover {
    background: #2563eb;
  }
  
  @media (max-width: 500px) { 
    header h1 { font-size: 1.2rem; } 
    #instructions {
      font-size: 0.7rem;
      bottom: 5px;
    }
    #mobile-controls {
      bottom: 60px;
    }
    #look-controls {
      bottom: 60px;
      width: 100px;
      height: 100px;
    }
    .mobile-btn {
      width: 45px;
      height: 45px;
      font-size: 1rem;
    }
    #mini-map {
      width: 100px;
      height: 100px;
      top: 60px;
    }
    .avatar-option {
      width: 150px;
      height: 225px;
    }
    #avatar-selection h2 {
      font-size: 1.4rem;
    }
    #location-info {
      top: 60px;
      font-size: 0.7rem;
      max-width: 150px;
    }
  }
</style>
</head>
<body>

<header>
  <h1>NFT Universe Explorer</h1>
  <div id="walletStatus">Not connected</div>
  <button id="connectBtn">Connect Wallet</button>
</header>

<a href='https://diamondrolls.github.io/thepremiumway/'> 
  <div class="homepage">Home</div>
</a>

<div id="canvas-container"></div>

<div id="instructions">
  <div id="desktop-instructions">Click to lock pointer and navigate with WASD keys. Move mouse to look around. Press SPACE to jump.</div>
  <div id="mobile-instructions" style="display:none;">Use controls to move and look around. Find NFTs everywhere!</div>
</div>

<div id="location-info">
  Location: Starting Area
</div>

<div id="mobile-controls">
  <div class="mobile-btn" id="forward-btn">‚Üë</div>
  <div style="display:flex; gap:10px;">
    <div class="mobile-btn" id="left-btn">‚Üê</div>
    <div class="mobile-btn" id="backward-btn">‚Üì</div>
    <div class="mobile-btn" id="right-btn">‚Üí</div>
  </div>
  <div class="mobile-btn" id="jump-btn" style="background: rgba(34, 197, 94, 0.7);">‚§¥</div>
</div>

<div id="look-controls"></div>

<div id="mini-map"></div>

<div id="nft-modal">
  <button id="close-modal">X</button>
  <img id="modal-image" src="" alt="NFT" />
  <div class="nft-info">
    <h3 id="modal-title"></h3>
    <p id="modal-description"></p>
    <p><strong>Price:</strong> <span id="modal-price"></span> ETH</p>
    <div class="nft-actions" id="modal-actions"></div>
  </div>
</div>

<div id="avatar-selection">
  <h2>Choose Your Explorer</h2>
  <div class="avatar-options">
    <div class="avatar-option" id="boy-avatar" data-avatar="boy"></div>
    <div class="avatar-option" id="girl-avatar" data-avatar="girl"></div>
  </div>
  <button id="confirm-avatar">Start Exploring</button>
</div>

<script>
/* ==============================
   CONFIGURATION
============================== */
const supabaseUrl = "https://fjtzodjudyctqacunlqp.supabase.co";
const supabaseKey = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZqdHpvZGp1ZHljdHFhY3VubHFwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgwNjA2OTQsImV4cCI6MjA3MzYzNjY5NH0.qR9RBsecfGUfKnbWgscmxloM-oEClJs_bo5YWoxFoE4";
const client = supabase.createClient(supabaseUrl, supabaseKey);

const NFT_CONTRACT_ADDRESS = "0x3ed4474a942d885d5651c8c56b238f3f4f524a5c";
const NFT_ABI = [
  { "constant":true,"inputs":[{"name":"tokenId","type":"uint256"}],"name":"ownerOf","outputs":[{"name":"","type":"address"}],"type":"function" },
  { "constant":false,"inputs":[{"name":"from","type":"address"},{"name":"to","type":"address"},{"name":"tokenId","type":"uint256"}],"name":"safeTransferFrom","outputs":[],"type":"function" }
];
const RECEIVER_ADDRESS = "0xaE0C180e071eE288B2F2f6ff6edaeF014678fFB7";

let web3, account, nftContract;

/* ==============================
   AVATAR SELECTION
============================== */
let selectedAvatar = null;
const avatarOptions = document.querySelectorAll('.avatar-option');
const confirmButton = document.getElementById('confirm-avatar');
const avatarSelection = document.getElementById('avatar-selection');

avatarOptions.forEach(option => {
  option.addEventListener('click', () => {
    // Remove selected class from all options
    avatarOptions.forEach(opt => opt.classList.remove('selected'));
    // Add selected class to clicked option
    option.classList.add('selected');
    selectedAvatar = option.getAttribute('data-avatar');
  });
});

confirmButton.addEventListener('click', () => {
  if (selectedAvatar) {
    avatarSelection.style.display = 'none';
    init3DScene();
    loadNFTs();
  } else {
    alert('Please select an avatar to continue');
  }
});

/* ==============================
   MOBILE DETECTION & CONTROLS
============================== */
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
let lookTouchId = null;
let lookStartX = 0, lookStartY = 0;
let lookX = 0, lookY = 0;
let velocity = new THREE.Vector3();
let canJump = true;

if (isMobile) {
  document.getElementById('desktop-instructions').style.display = 'none';
  document.getElementById('mobile-instructions').style.display = 'block';
  
  // Set up mobile movement controls
  document.getElementById('forward-btn').addEventListener('touchstart', (e) => {
    e.preventDefault();
    moveForward = true;
  });
  document.getElementById('forward-btn').addEventListener('touchend', (e) => {
    e.preventDefault();
    moveForward = false;
  });
  
  document.getElementById('backward-btn').addEventListener('touchstart', (e) => {
    e.preventDefault();
    moveBackward = true;
  });
  document.getElementById('backward-btn').addEventListener('touchend', (e) => {
    e.preventDefault();
    moveBackward = false;
  });
  
  document.getElementById('left-btn').addEventListener('touchstart', (e) => {
    e.preventDefault();
    moveLeft = true;
  });
  document.getElementById('left-btn').addEventListener('touchend', (e) => {
    e.preventDefault();
    moveLeft = false;
  });
  
  document.getElementById('right-btn').addEventListener('touchstart', (e) => {
    e.preventDefault();
    moveRight = true;
  });
  document.getElementById('right-btn').addEventListener('touchend', (e) => {
    e.preventDefault();
    moveRight = false;
  });
  
  document.getElementById('jump-btn').addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (canJump) {
      velocity.y += 350;
      canJump = false;
    }
  });
  
  // Set up look controls
  const lookControls = document.getElementById('look-controls');
  lookControls.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (lookTouchId === null) {
      const touch = e.touches[0];
      lookTouchId = touch.identifier;
      lookStartX = touch.clientX;
      lookStartY = touch.clientY;
    }
  });
  
  lookControls.addEventListener('touchmove', (e) => {
    e.preventDefault();
    for (let i = 0; i < e.changedTouches.length; i++) {
      const touch = e.changedTouches[i];
      if (touch.identifier === lookTouchId) {
        const deltaX = touch.clientX - lookStartX;
        const deltaY = touch.clientY - lookStartY;
        
        lookX = deltaX * 0.5;
        lookY = deltaY * 0.5;
        
        lookStartX = touch.clientX;
        lookStartY = touch.clientY;
        break;
      }
    }
  });
  
  lookControls.addEventListener('touchend', (e) => {
    e.preventDefault();
    for (let i = 0; i < e.changedTouches.length; i++) {
      const touch = e.changedTouches[i];
      if (touch.identifier === lookTouchId) {
        lookTouchId = null;
        lookX = 0;
        lookY = 0;
        break;
      }
    }
  });
}

/* ==============================
   3D SCENE SETUP
============================== */
let scene, camera, renderer, controls;
let nftObjects = [], environmentObjects = [], buildingObjects = [];
let raycaster, mouse;
let currentIntersected = null;
let miniMapScene, miniMapCamera, miniMapRenderer;
let playerAvatar;
let worldSize = 800; // Reduced world size to prevent roaming off
let worldBoundary = worldSize / 2 - 50; // Boundary with 50px buffer
let moon;
let clock = new THREE.Clock();
let prevTime = 0;

// Collision detection variables - MODIFIED FOR ROOF JUMPING
let collisionObjects = [];
let roofObjects = []; // For roof surfaces you can walk on
let playerCollider = new THREE.Box3();
let playerSize = new THREE.Vector3(2, 10, 2); // Player collision box size
let playerOnRoof = false; // Track if player is on a roof
let currentRoof = null; // Track which roof player is on

function init3DScene() {
  // Create scene
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000033); // Dark blue for space
  scene.fog = new THREE.Fog(0x000033, 100, 2000);
  
  // Create camera
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
  camera.position.set(0, 10, 50);
  
  // Create renderer
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  document.getElementById('canvas-container').appendChild(renderer.domElement);
  
  // Add lighting
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
  scene.add(ambientLight);
  
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  directionalLight.position.set(100, 200, 100);
  directionalLight.castShadow = true;
  directionalLight.shadow.mapSize.width = 2048;
  directionalLight.shadow.mapSize.height = 2048;
  directionalLight.shadow.camera.near = 0.5;
  directionalLight.shadow.camera.far = 2000;
  directionalLight.shadow.camera.left = -500;
  directionalLight.shadow.camera.right = 500;
  directionalLight.shadow.camera.top = 500;
  directionalLight.shadow.camera.bottom = -500;
  scene.add(directionalLight);
  
  // Create the world
  createWorld();
  
  // Create player avatar
  createPlayerAvatar();
  
  // Set up controls
  if (!isMobile) {
    controls = new THREE.PointerLockControls(camera, document.body);
    
    document.addEventListener('click', function() {
      if (!controls.isLocked) {
        controls.lock();
      }
    });
    
    controls.addEventListener('lock', function() {
      document.getElementById('instructions').style.display = 'none';
    });
    
    controls.addEventListener('unlock', function() {
      document.getElementById('instructions').style.display = 'block';
    });
    
    // Keyboard controls for desktop
    const onKeyDown = function (event) {
      switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
          moveForward = true;
          break;
        case 'ArrowLeft':
        case 'KeyA':
          moveLeft = true;
          break;
        case 'ArrowDown':
        case 'KeyS':
          moveBackward = true;
          break;
        case 'ArrowRight':
        case 'KeyD':
          moveRight = true;
          break;
        case 'Space':
          if (canJump) {
            velocity.y += 350;
            canJump = false;
          }
          break;
      }
    };
    
    const onKeyUp = function (event) {
      switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
          moveForward = false;
          break;
        case 'ArrowLeft':
        case 'KeyA':
          moveLeft = false;
          break;
        case 'ArrowDown':
        case 'KeyS':
          moveBackward = false;
          break;
        case 'ArrowRight':
        case 'KeyD':
          moveRight = false;
          break;
      }
    };
    
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);
  }
  
  // Set up raycaster for object interaction
  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2();
  
  // Handle window resize
  window.addEventListener('resize', onWindowResize);
  
  // Initialize mini-map
  initMiniMap();
  
  // Start animation
  animate();
}

function createWorld() {
  // Create massive ground plane
  const groundGeometry = new THREE.PlaneGeometry(worldSize, worldSize, 100, 100);
  const groundMaterial = new THREE.MeshLambertMaterial({ 
    color: 0x4ADE80, // Bright green for grass
    side: THREE.DoubleSide
  });
  const ground = new THREE.Mesh(groundGeometry, groundMaterial);
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);
  
  // Create city with buildings (only buildings that are on the map)
  createCity();
  
  // Create moon in the sky
  createMoon();
  
  // Add boundary walls to prevent going off map
  createBoundaryWalls();
}

function createBoundaryWalls() {
  const wallHeight = 100;
  const wallMaterial = new THREE.MeshLambertMaterial({ 
    color: 0x374151,
    transparent: true,
    opacity: 0.7
  });
  
  // Create walls around the perimeter
  const wallGeometry = new THREE.PlaneGeometry(worldSize, wallHeight);
  
  // North wall
  const northWall = new THREE.Mesh(wallGeometry, wallMaterial);
  northWall.position.set(0, wallHeight/2, -worldBoundary);
  northWall.rotation.x = Math.PI / 2;
  scene.add(northWall);
  
  // South wall
  const southWall = new THREE.Mesh(wallGeometry, wallMaterial);
  southWall.position.set(0, wallHeight/2, worldBoundary);
  southWall.rotation.x = -Math.PI / 2;
  scene.add(southWall);
  
  // East wall
  const eastWall = new THREE.Mesh(wallGeometry, wallMaterial);
  eastWall.position.set(worldBoundary, wallHeight/2, 0);
  eastWall.rotation.x = Math.PI / 2;
  eastWall.rotation.y = Math.PI / 2;
  scene.add(eastWall);
  
  // West wall
  const westWall = new THREE.Mesh(wallGeometry, wallMaterial);
  westWall.position.set(-worldBoundary, wallHeight/2, 0);
  westWall.rotation.x = Math.PI / 2;
  westWall.rotation.y = -Math.PI / 2;
  scene.add(westWall);
}

function createCity() {
  const cityGroup = new THREE.Group();
  const buildingColors = [0x3B82F6, 0xEF4444, 0x10B981, 0xF59E0B, 0x8B5CF6];
  
  // Create only buildings that are on the map (reduced grid size)
  const gridSize = 5; // Further reduced from 11 to 5 (25 buildings total)
  const spacing = 60; // Increased spacing for better navigation
  
  for (let x = 0; x < gridSize; x++) {
    for (let z = 0; z < gridSize; z++) {
      const height = 30 + Math.random() * 70; // Slightly taller buildings
      const width = 20 + Math.random() * 15;
      const depth = 20 + Math.random() * 15;
      
      const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
      const buildingMaterial = new THREE.MeshLambertMaterial({ 
        color: buildingColors[Math.floor(Math.random() * buildingColors.length)] 
      });
      
      const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
      
      // Position buildings in a tighter cluster in the center
      building.position.set(
        (x - gridSize/2) * spacing,
        height / 2,
        (z - gridSize/2) * spacing - 100 // Moved closer to center
      );
      
      building.castShadow = true;
      building.receiveShadow = true;
      cityGroup.add(building);
      buildingObjects.push(building);
      
      // Add building to collision objects
      const buildingBox = new THREE.Box3().setFromObject(building);
      collisionObjects.push(buildingBox);
      
      // Create a solid roof plane for walking on top of the building
      createBuildingRoof(building.position.x, building.position.y + height/2, building.position.z, width, depth);
    }
  }
  
  scene.add(cityGroup);
}

function createBuildingRoof(x, y, z, width, depth) {
  // Create a solid roof plane for collision
  const roofGeometry = new THREE.PlaneGeometry(width, depth);
  const roofMaterial = new THREE.MeshLambertMaterial({ 
    color: 0x1F2937, // Dark gray for roofs
    side: THREE.DoubleSide
  });
  
  const roof = new THREE.Mesh(roofGeometry, roofMaterial);
  roof.position.set(x, y + 0.1, z); // Position slightly above the building
  roof.rotation.x = Math.PI / 2; // Rotate to be horizontal
  
  // Make the roof solid and visible
  roof.receiveShadow = true;
  roof.castShadow = true;
  
  scene.add(roof);
  
  // Add roof to collision objects for walking on
  const roofBox = new THREE.Box3().setFromCenterAndSize(
    new THREE.Vector3(x, y + 0.1, z),
    new THREE.Vector3(width, 0.2, depth)
  );
  roofObjects.push({
    box: roofBox,
    position: new THREE.Vector3(x, y + 0.1, z),
    width: width,
    depth: depth
  });
  
  // Also add the roof to the main collision objects to prevent falling through
  collisionObjects.push(roofBox);
}

function createMoon() {
  const moonGroup = new THREE.Group();
  
  // Create the moon sphere
  const moonGeometry = new THREE.SphereGeometry(100, 32, 32);
  const moonMaterial = new THREE.MeshLambertMaterial({ color: 0xE5E7EB });
  moon = new THREE.Mesh(moonGeometry, moonMaterial);
  
  // Position the moon high in the sky
  moon.position.set(0, 800, -800);
  moon.castShadow = true;
  moon.receiveShadow = true;
  moonGroup.add(moon);
  
  // Add craters to the moon
  for (let i = 0; i < 20; i++) {
    const craterGeometry = new THREE.SphereGeometry(5 + Math.random() * 15, 16, 16);
    const craterMaterial = new THREE.MeshLambertMaterial({ color: 0x9CA3AF });
    
    const crater = new THREE.Mesh(craterGeometry, craterMaterial);
    
    // Position craters randomly on the moon's surface
    const phi = Math.random() * Math.PI;
    const theta = Math.random() * Math.PI * 2;
    const radius = 100;
    
    crater.position.set(
      radius * Math.sin(phi) * Math.cos(theta),
      radius * Math.sin(phi) * Math.sin(theta),
      radius * Math.cos(phi)
    );
    
    moonGroup.add(crater);
  }
  
  scene.add(moonGroup);
}

function createPlayerAvatar() {
  // Create a simple 3D representation of the selected avatar
  const group = new THREE.Group();
  
  if (selectedAvatar === 'boy') {
    // Create boy avatar - blue color scheme
    const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 8);
    const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x3B82F6 });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    body.position.y = 1.5;
    group.add(body);
    
    const headGeometry = new THREE.SphereGeometry(0.6, 8, 8);
    const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFCD34D });
    const head = new THREE.Mesh(headGeometry, headMaterial);
    head.position.y = 2.8;
    group.add(head);
    
    // Add arms
    const armGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1, 6);
    const armMaterial = new THREE.MeshLambertMaterial({ color: 0x3B82F6 });
    
    const leftArm = new THREE.Mesh(armGeometry, armMaterial);
    leftArm.position.set(-0.7, 1.5, 0);
    leftArm.rotation.z = Math.PI / 6;
    group.add(leftArm);
    
    const rightArm = new THREE.Mesh(armGeometry, armMaterial);
    rightArm.position.set(0.7, 1.5, 0);
    rightArm.rotation.z = -Math.PI / 6;
    group.add(rightArm);
    
    // Add legs
    const legGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1.2, 6);
    const legMaterial = new THREE.MeshLambertMaterial({ color: 0x1E40AF });
    
    const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
    leftLeg.position.set(-0.3, 0.5, 0);
    group.add(leftLeg);
    
    const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
    rightLeg.position.set(0.3, 0.5, 0);
    group.add(rightLeg);
    
  } else if (selectedAvatar === 'girl') {
    // Create girl avatar - pink color scheme
    const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 8);
    const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xEC4899 });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    body.position.y = 1.5;
    group.add(body);
    
    const headGeometry = new THREE.SphereGeometry(0.6, 8, 8);
    const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFCD34D });
    const head = new THREE.Mesh(headGeometry, headMaterial);
    head.position.y = 2.8;
    group.add(head);
    
    // Add arms
    const armGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1, 6);
    const armMaterial = new THREE.MeshLambertMaterial({ color: 0xEC4899 });
    
    const leftArm = new THREE.Mesh(armGeometry, armMaterial);
    leftArm.position.set(-0.7, 1.5, 0);
    leftArm.rotation.z = Math.PI / 6;
    group.add(leftArm);
    
    const rightArm = new THREE.Mesh(armGeometry, armMaterial);
    rightArm.position.set(0.7, 1.5, 0);
    rightArm.rotation.z = -Math.PI / 6;
    group.add(rightArm);
    
    // Add legs
    const legGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1.2, 6);
    const legMaterial = new THREE.MeshLambertMaterial({ color: 0xBE185D });
    
    const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
    leftLeg.position.set(-0.3, 0.5, 0);
    group.add(leftLeg);
    
    const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
    rightLeg.position.set(0.3, 0.5, 0);
    group.add(rightLeg);
    
    // Add a skirt
    const skirtGeometry = new THREE.ConeGeometry(0.7, 0.5, 8);
    const skirtMaterial = new THREE.MeshLambertMaterial({ color: 0xF472B6 });
    const skirt = new THREE.Mesh(skirtGeometry, skirtMaterial);
    skirt.position.y = 0.9;
    skirt.rotation.x = Math.PI;
    group.add(skirt);
  }
  
  // Position the avatar at the starting point
  group.position.set(0, 5, 0);
  group.castShadow = true;
  scene.add(group);
  
  playerAvatar = group;
}

function initMiniMap() {
  miniMapScene = new THREE.Scene();
  miniMapCamera = new THREE.OrthographicCamera(-worldSize/2, worldSize/2, worldSize/2, -worldSize/2, 0.1, 2000);
  miniMapCamera.position.y = 500;
  miniMapCamera.lookAt(0, 0, 0);
  
  const miniMapCanvas = document.createElement('canvas');
  miniMapCanvas.width = 120;
  miniMapCanvas.height = 120;
  document.getElementById('mini-map').appendChild(miniMapCanvas);
  
  miniMapRenderer = new THREE.WebGLRenderer({ 
    canvas: miniMapCanvas,
    antialias: false 
  });
  miniMapRenderer.setSize(120, 120);
  miniMapRenderer.setClearColor(0x000000, 0.5);
  
  // Add ground to mini-map
  const groundGeometry = new THREE.PlaneGeometry(worldSize, worldSize);
  const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x4ADE80 });
  const ground = new THREE.Mesh(groundGeometry, groundMaterial);
  ground.rotation.x = -Math.PI / 2;
  miniMapScene.add(ground);
  
  // Add player indicator
  const playerGeometry = new THREE.CircleGeometry(10, 8);
  const playerMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
  const playerIndicator = new THREE.Mesh(playerGeometry, playerMaterial);
  playerIndicator.rotation.x = -Math.PI / 2;
  miniMapScene.add(playerIndicator);
  
  // Add NFT indicators
  const nftIndicatorGeometry = new THREE.CircleGeometry(8, 6);
  const nftIndicatorMaterial = new THREE.MeshBasicMaterial({ color: 0x3B82F6 });
  
  window.updateMiniMap = function() {
    // Update player position
    playerIndicator.position.x = camera.position.x;
    playerIndicator.position.z = camera.position.z;
    
    // Update player avatar position
    if (playerAvatar) {
      playerAvatar.position.x = camera.position.x;
      playerAvatar.position.z = camera.position.z;
      // Make avatar face the direction the camera is looking
      playerAvatar.rotation.y = camera.rotation.y;
    }
    
    // Update location info
    updateLocationInfo();
    
    // Clear previous NFT indicators
    miniMapScene.children.forEach((child, index) => {
      if (child.userData && child.userData.isNFTIndicator) {
        miniMapScene.children.splice(index, 1);
      }
    });
    
    // Add current NFT indicators
    nftObjects.forEach(nft => {
      const indicator = new THREE.Mesh(nftIndicatorGeometry, nftIndicatorMaterial);
      indicator.position.x = nft.position.x;
      indicator.position.z = nft.position.z;
      indicator.rotation.x = -Math.PI / 2;
      indicator.userData = { isNFTIndicator: true };
      miniMapScene.add(indicator);
    });
    
    miniMapRenderer.render(miniMapScene, miniMapCamera);
  };
}

function updateLocationInfo() {
  const locationInfo = document.getElementById('location-info');
  const x = camera.position.x;
  const z = camera.position.z;
  const y = camera.position.y;
  
  // Check if player is in the city
  if (x > -200 && x < 200 && z > -200 && z < 200) {
    if (playerOnRoof) {
      locationInfo.textContent = "Location: City Center (On Roof)";
    } else {
      locationInfo.textContent = "Location: City Center";
    }
  }
  // Check if player is on the moon
  else if (y > 600) {
    locationInfo.textContent = "Location: Moon Surface";
  }
  // Otherwise in the grass fields
  else {
    locationInfo.textContent = "Location: Grass Fields";
  }
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

// MODIFIED COLLISION DETECTION FOR ROOF JUMPING
function checkCollisions(newPosition) {
  // Update player collider position and size
  playerCollider.setFromCenterAndSize(
    new THREE.Vector3(newPosition.x, newPosition.y + playerSize.y/2, newPosition.z),
    playerSize
  );
  
  // Check for collisions with all collision objects (buildings AND roofs)
  for (let i = 0; i < collisionObjects.length; i++) {
    if (playerCollider.intersectsBox(collisionObjects[i])) {
      return true; // Collision detected
    }
  }
  
  return false; // No collision
}

// NEW FUNCTION: Check if player is on a roof
function checkRoofCollision(newPosition) {
  playerOnRoof = false;
  currentRoof = null;
  
  // Check if player is on top of any roof
  for (let i = 0; i < roofObjects.length; i++) {
    const roof = roofObjects[i];
    const roofBox = roof.box;
    
    // Check if player is above the roof and within its bounds
    if (newPosition.x >= roofBox.min.x && newPosition.x <= roofBox.max.x &&
        newPosition.z >= roofBox.min.z && newPosition.z <= roofBox.max.z &&
        Math.abs(newPosition.y - roofBox.max.y) < 5) { // Within 5 units of roof top
      
      playerOnRoof = true;
      currentRoof = roof;
      return true;
    }
  }
  
  return false;
}

// NEW FUNCTION: Snap player to roof when landing
function snapToRoof(newPosition) {
  if (currentRoof) {
    newPosition.y = currentRoof.box.max.y;
    velocity.y = 0;
    canJump = true;
    return true;
  }
  return false;
}

function animate() {
  requestAnimationFrame(animate);
  
  const time = performance.now();
  const delta = (time - prevTime) / 1000;
  
  // Handle movement
  if (controls && controls.isLocked) {
    const moveSpeed = 200.0 * delta;
    
    // Store current position for collision detection
    const currentPosition = camera.position.clone();
    
    // Calculate new position based on movement
    const newPosition = currentPosition.clone();
    
    if (moveForward) {
      newPosition.z -= moveSpeed;
    }
    if (moveBackward) {
      newPosition.z += moveSpeed;
    }
    if (moveLeft) {
      newPosition.x -= moveSpeed;
    }
    if (moveRight) {
      newPosition.x += moveSpeed;
    }
    
    // Apply gravity
    velocity.y -= 9.8 * 100.0 * delta;
    newPosition.y += (velocity.y * delta);
    
    // Check if player is on a roof
    const wasOnRoof = playerOnRoof;
    checkRoofCollision(newPosition);
    
    // If player is on a roof, snap to roof height
    if (playerOnRoof && velocity.y <= 0) {
      snapToRoof(newPosition);
    }
    
    // Check for collisions before updating position
    if (!checkCollisions(newPosition)) {
      // No collision, update position
      camera.position.copy(newPosition);
    } else {
      // Collision detected, revert to original position
      // But allow vertical movement (jumping) if we're above the object
      const verticalCheck = new THREE.Vector3(currentPosition.x, newPosition.y, currentPosition.z);
      if (!checkCollisions(verticalCheck)) {
        // Allow vertical movement (jumping on objects)
        camera.position.y = newPosition.y;
      }
      
      // Reset horizontal velocity on collision
      velocity.x = 0;
      velocity.z = 0;
    }
    
    // Prevent going below ground level
    if (camera.position.y < 5 && !playerOnRoof) {
      camera.position.y = 5;
      velocity.y = 0;
      canJump = true;
    }
    
    // Prevent going outside world boundaries
    if (camera.position.x > worldBoundary) {
      camera.position.x = worldBoundary;
    }
    if (camera.position.x < -worldBoundary) {
      camera.position.x = -worldBoundary;
    }
    if (camera.position.z > worldBoundary) {
      camera.position.z = worldBoundary;
    }
    if (camera.position.z < -worldBoundary) {
      camera.position.z = -worldBoundary;
    }
  }
  
  // Handle movement for mobile
  if (isMobile) {
    const moveSpeed = 100.0 * delta;
    
    // Store current position for collision detection
    const currentPosition = camera.position.clone();
    
    // Calculate new position based on movement
    const newPosition = currentPosition.clone();
    
    if (moveForward) {
      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);
      forward.y = 0;
      forward.normalize();
      newPosition.add(forward.multiplyScalar(moveSpeed));
    }
    if (moveBackward) {
      const backward = new THREE.Vector3();
      camera.getWorldDirection(backward);
      backward.y = 0;
      backward.normalize();
      newPosition.sub(backward.multiplyScalar(moveSpeed));
    }
    if (moveLeft) {
      const left = new THREE.Vector3();
      camera.getWorldDirection(left);
      left.y = 0;
      left.normalize();
      left.cross(camera.up);
      newPosition.sub(left.multiplyScalar(moveSpeed));
    }
    if (moveRight) {
      const right = new THREE.Vector3();
      camera.getWorldDirection(right);
      right.y = 0;
      right.normalize();
      right.cross(camera.up);
      newPosition.add(right.multiplyScalar(moveSpeed));
    }
    
    // Apply gravity for mobile
    velocity.y -= 9.8 * 100.0 * delta;
    newPosition.y += (velocity.y * delta);
    
    // Check if player is on a roof
    const wasOnRoof = playerOnRoof;
    checkRoofCollision(newPosition);
    
    // If player is on a roof, snap to roof height
    if (playerOnRoof && velocity.y <= 0) {
      snapToRoof(newPosition);
    }
    
    // Check for collisions before updating position
    if (!checkCollisions(newPosition)) {
      // No collision, update position
      camera.position.copy(newPosition);
    } else {
      // Collision detected, revert to original position
      // But allow vertical movement (jumping) if we're above the object
      const verticalCheck = new THREE.Vector3(currentPosition.x, newPosition.y, currentPosition.z);
      if (!checkCollisions(verticalCheck)) {
        // Allow vertical movement (jumping on objects)
        camera.position.y = newPosition.y;
      }
    }
    
    // Prevent going below ground level
    if (camera.position.y < 5 && !playerOnRoof) {
      camera.position.y = 5;
      velocity.y = 0;
      canJump = true;
    }
    
    // Prevent going outside world boundaries for mobile
    if (camera.position.x > worldBoundary) {
      camera.position.x = worldBoundary;
    }
    if (camera.position.x < -worldBoundary) {
      camera.position.x = -worldBoundary;
    }
    if (camera.position.z > worldBoundary) {
      camera.position.z = worldBoundary;
    }
    if (camera.position.z < -worldBoundary) {
      camera.position.z = -worldBoundary;
    }
    
    // Handle look for mobile
    if (lookX !== 0 || lookY !== 0) {
      camera.rotation.y -= lookX * 0.01;
      camera.rotation.x -= lookY * 0.01;
      camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
    }
  }
  
  // Update raycaster for object interaction
  if (!isMobile && controls && controls.isLocked) {
    raycaster.setFromCamera(mouse, camera);
  } else {
    // For mobile, we'll use a fixed direction (forward)
    raycaster.set(camera.position, camera.getWorldDirection(new THREE.Vector3()));
  }
  
  const intersects = raycaster.intersectObjects(nftObjects);
  
  if (intersects.length > 0) {
    if (currentIntersected !== intersects[0].object) {
      // Reset previous intersection
      if (currentIntersected) {
        currentIntersected.material.emissive.setHex(currentIntersected.userData.originalEmissive);
      }
      
      // Set new intersection
      currentIntersected = intersects[0].object;
      currentIntersected.userData.originalEmissive = currentIntersected.material.emissive.getHex();
      currentIntersected.material.emissive.setHex(0x3b82f6);
      
      // Change cursor to pointer
      if (!isMobile) {
        document.body.style.cursor = 'pointer';
      }
    }
  } else {
    if (currentIntersected) {
      currentIntersected.material.emissive.setHex(currentIntersected.userData.originalEmissive);
      currentIntersected = null;
      if (!isMobile) {
        document.body.style.cursor = 'auto';
      }
    }
  }
  
  // Update mini-map
  if (window.updateMiniMap) {
    window.updateMiniMap();
  }
  
  prevTime = time;
  renderer.render(scene, camera);
}

function createNFTPlane(nftData, position, isMoonNFT = false) {
  // Create a plane for the NFT image
  const geometry = new THREE.PlaneGeometry(8, 8);
  
  // Create texture loader
  const textureLoader = new THREE.TextureLoader();
  const texture = textureLoader.load(nftData.image_url, function() {
    // Texture loaded
  });
  
  const material = new THREE.MeshStandardMaterial({ 
    map: texture,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.9
  });
  
  const plane = new THREE.Mesh(geometry, material);
  plane.position.set(position.x, position.y, position.z);
  
  // Rotate to face a random direction
  plane.rotation.y = Math.random() * Math.PI * 2;
  
  // Store NFT data for interaction
  plane.userData.nftData = nftData;
  plane.userData.originalEmissive = 0x000000;
  
  scene.add(plane);
  nftObjects.push(plane);
  
  // Add a subtle glow effect - different color for moon NFTs
  const glowGeometry = new THREE.PlaneGeometry(8.5, 8.5);
  const glowMaterial = new THREE.MeshBasicMaterial({ 
    color: isMoonNFT ? 0xFFD700 : 0x3b82f6, // Gold for moon, blue for earth
    transparent: true,
    opacity: 0.4,
    side: THREE.DoubleSide
  });
  const glow = new THREE.Mesh(glowGeometry, glowMaterial);
  glow.position.copy(plane.position);
  glow.rotation.copy(plane.rotation);
  scene.add(glow);
  
  // Make glow part of the NFT object for interaction
  plane.userData.glow = glow;
}

function openNFTModal(nftData) {
  document.getElementById('modal-image').src = nftData.image_url;
  document.getElementById('modal-title').textContent = `${nftData.collection || 'Untitled'} #${nftData.token_id ?? ''}`;
  document.getElementById('modal-description').textContent = nftData.description || 'No description available';
  document.getElementById('modal-price').textContent = nftData.price_eth ?? 'N/A';
  
  let buttons = "";
  if (!account) {
    buttons = "<p>üîí Connect wallet to interact.</p>";
  } else if (nftData.owner?.toLowerCase() === account.toLowerCase()) {
    buttons = `
      <button onclick="sellNFT(${nftData.token_id})">Sell</button>
      <button onclick="transferNFT(${nftData.token_id})">Transfer ($6 fee)</button>
    `;
  } else {
    buttons = `<button onclick="buyNFT(${nftData.token_id}, ${nftData.price_eth || 0})">Buy ($6 fee)</button>`;
  }
  
  document.getElementById('modal-actions').innerHTML = buttons;
  document.getElementById('nft-modal').style.display = 'block';
}

document.getElementById('close-modal').addEventListener('click', function() {
  document.getElementById('nft-modal').style.display = 'none';
});

// Handle click/tap on NFT
document.addEventListener('click', function onClick(event) {
  if (((!isMobile && controls && controls.isLocked) || (isMobile && currentIntersected)) && currentIntersected) {
    const nftData = currentIntersected.userData.nftData;
    openNFTModal(nftData);
  }
});

/* ==============================
   CONNECT WALLET (MetaMask + WalletConnect)
============================== */
async function connectWallet() {
  try {
    if (window.ethereum) {
      web3 = new Web3(window.ethereum);
      const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
      account = accounts[0];
    } else {
      const provider = new WalletConnectProvider.default({
        rpc: { 1: "https://mainnet.infura.io/v3/d71dd33696d449e488a88bdc02a6093c" },
      });
      await provider.enable();
      web3 = new Web3(provider);
      const accounts = await web3.eth.getAccounts();
      account = accounts[0];
    }

    document.getElementById("walletStatus").innerText =
      `‚úÖ Connected: ${account.slice(0, 6)}...${account.slice(-4)}`;

    nftContract = new web3.eth.Contract(NFT_ABI, NFT_CONTRACT_ADDRESS);
    if (avatarSelection.style.display === 'none') {
      loadNFTs();
    }

  } catch (err) {
    console.error(err);
    alert("Failed to connect wallet.");
  }
}

document.getElementById("connectBtn").addEventListener("click", connectWallet);

/* ==============================
   LOAD NFTs
============================== */
async function loadNFTs() {
  const { data, error } = await client.from("nfts").select("*").order("created_at", { ascending: false });

  if (error) {
    console.error(error);
    return;
  }
  
  if (!data || data.length === 0) {
    return;
  }

  // Clear existing NFTs
  nftObjects.forEach(obj => {
    scene.remove(obj);
    if (obj.userData.glow) {
      scene.remove(obj.userData.glow);
    }
  });
  nftObjects = [];
  
  // Split NFTs between Earth and Moon
  const earthNFTs = data.slice(0, Math.floor(data.length * 0.7)); // 70% on Earth
  const moonNFTs = data.slice(Math.floor(data.length * 0.7)); // 30% on Moon
  
  // Position Earth NFTs randomly across the terrain, CLOSE to the ground
  earthNFTs.forEach((nft, index) => {
    // Create positions in a circular pattern
    const angle = (index / earthNFTs.length) * Math.PI * 2;
    const radius = 100 + Math.random() * 300; // Closer to center
    
    const x = Math.cos(angle) * radius;
    const z = Math.sin(angle) * radius;
    
    // Add some randomness to positions
    const randomOffsetX = (Math.random() - 0.5) * 50;
    const randomOffsetZ = (Math.random() - 0.5) * 50;
    
    // Get terrain height at this position (simple approximation)
    let terrainHeight = 5;
    if (Math.sqrt((x + randomOffsetX)**2 + (z + randomOffsetZ)**2) > 200) {
      terrainHeight = 20 + Math.random() * 50; // Higher in mountains
    } else if (x > -200 && x < 200 && z > -200 && z < 200) {
      terrainHeight = 15 + Math.random() * 30; // In city
    }
    
    // Position NFTs very close to the ground (about 50px above)
    createNFTPlane(nft, { 
      x: x + randomOffsetX, 
      y: terrainHeight + 4, // Only 4 units above terrain
      z: z + randomOffsetZ 
    }, false);
  });
  
  // Position Moon NFTs on the moon surface
  moonNFTs.forEach((nft, index) => {
    // Position NFTs randomly on the moon's surface
    const phi = Math.acos(2 * Math.random() - 1);
    const theta = Math.random() * Math.PI * 2;
    const radius = 110; // Slightly above the moon's surface
    
    const x = radius * Math.sin(phi) * Math.cos(theta);
    const y = radius * Math.sin(phi) * Math.sin(theta);
    const z = radius * Math.cos(phi);
    
    // Offset by moon position
    createNFTPlane(nft, { 
      x: moon.position.x + x, 
      y: moon.position.y + y, 
      z: moon.position.z + z 
    }, true);
  });
}

/* ==============================
   BUY NFT
============================== */
async function buyNFT(tokenId, priceEth) {
  if (!account) return alert("Connect wallet first.");
  try {
    const totalEth = web3.utils.toWei((Number(priceEth) + 6/1000).toString(), 'ether');
    await web3.eth.sendTransaction({ from: account, to: RECEIVER_ADDRESS, value: totalEth });

    await client.from("nfts").update({ owner: account, sold: true }).eq("token_id", tokenId);
    alert("‚úÖ NFT purchased! Payment sent.");
    loadNFTs();
    document.getElementById('nft-modal').style.display = 'none';
  } catch(err) { console.error(err); alert("Buy failed: " + err.message); }
}

/* ==============================
   SELL NFT
============================== */
async function sellNFT(tokenId) {
  if (!account) return alert("Connect wallet first.");
  const priceEth = prompt("Enter sale price in ETH:");
  if (!priceEth) return;
  await client.from("nfts").update({ sold: false, price_eth: priceEth, owner: account }).eq("token_id", tokenId);
  alert("‚úÖ NFT listed for sale!");
  loadNFTs();
  document.getElementById('nft-modal').style.display = 'none';
}

/* ==============================
   TRANSFER NFT
============================== */
async function transferNFT(tokenId) {
  if (!account) return alert("Connect wallet first.");
  const recipient = prompt("Enter recipient wallet address:");
  if (!recipient) return;
  try {
    const feeEth = web3.utils.toWei((6/1000).toString(), 'ether');
    await web3.eth.sendTransaction({ from: account, to: RECEIVER_ADDRESS, value: feeEth });

    await nftContract.methods.safeTransferFrom(account, recipient, tokenId).send({ from: account });

    await client.from("nfts").update({ owner: recipient }).eq("token_id", tokenId);
    alert("‚úÖ NFT transferred! Fee sent.");
    loadNFTs();
    document.getElementById('nft-modal').style.display = 'none';
  } catch(err) { console.error(err); alert("Transfer failed: " + err.message); }
}

// The 3D scene will be initialized after avatar selection
</script>

</body>
</html>
